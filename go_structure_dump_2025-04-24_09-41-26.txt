ðŸ”Ž Dump de Estrutura â€“ Projeto Go
Raiz do projeto : /Users/eduardomarcelino/Desktop/Placemaking project/placemaking-server-go
Gerado em       : Thu Apr 24 09:41:26 -03 2025
------------------------------------------------------------

ðŸ“„ Arquivo : .env
ðŸ“‚ Pasta   : .
ðŸ§­ Caminho : .env
--------------------------------------
ðŸ“œ ConteÃºdo:

ENV = prod
PROJECT_NAME=Placemaking server
SUPABASE_URL=https://vskajxbphfddzjogtiiy.supabase.co
SUPABASE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZza2FqeGJwaGZkZHpqb2d0aWl5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE2OTI1ODUsImV4cCI6MjA1NzI2ODU4NX0.0SOw-u8xQpoEyEo8-zy2Y31CXJADo84q4iyatWKs6dE
GMAIL_USER=placemakingapp@gmail.com
GMAIL_PASSWORD=tikystfabnldmaqz
JWT_SECRET=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZza2FqeGJwaGZkZHpqb2d0a


============================================================


ðŸ“„ Arquivo : README.MD
ðŸ“‚ Pasta   : .
ðŸ§­ Caminho : README.MD
--------------------------------------
ðŸ“œ ConteÃºdo:

# Para rodar localmente use no terminal:

```
go run .\server\server.go
```


============================================================


ðŸ“„ Arquivo : settings.go
ðŸ“‚ Pasta   : config
ðŸ§­ Caminho : config/settings.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package config

import (
	"log"
	"os"
	"github.com/joho/godotenv"
)

// Settings armazena as configuraÃ§Ãµes do .env
type Settings struct {
	Env         string
	ProjectName string
	SupabaseURL string
	SupabaseKey string
	GmailUser   string
	GmailPass   string
	JwtSecret   string
}

// LoadSettings carrega as variÃ¡veis do .env para a struct Settings
func LoadSettings() *Settings {
	err := godotenv.Load()
	if err != nil {
		log.Println("Erro ao carregar .env, usando variÃ¡veis do sistema.")
	}

	return &Settings{
		Env:         os.Getenv("ENV"),
		ProjectName: os.Getenv("PROJECT_NAME"),
		SupabaseURL: os.Getenv("SUPABASE_URL"),
		SupabaseKey: os.Getenv("SUPABASE_KEY"),
		GmailUser:   os.Getenv("GMAIL_USER"),
		GmailPass:   os.Getenv("GMAIL_PASSWORD"),
		JwtSecret:   os.Getenv("JWT_SECRET"),
	}
}

============================================================


ðŸ“„ Arquivo : auth_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/auth_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"fmt"
	"log"
	"net/http"
	"strings"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"

	"github.com/gin-gonic/gin"
)

func Register(c* gin.Context) {

	var createUserData models.CreateUser

	if err := c.ShouldBindJSON(&createUserData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "JSON invÃ¡lido"})
		return
	}

	user, temporaryPassword, err:= services.RegisterUser(createUserData)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err})
	}

	data := map[string]interface{}{
		"user": map[string]interface{}{
			"email": user.Email,
			"name":  user.Name,
		},
		"temporary_password": temporaryPassword,
	}
	
	err = services.SendUserData(data)
	if err != nil {
		log.Println("Erro ao enviar e-mail:", err)
	}

	c.JSON(http.StatusCreated, gin.H{"message": "UsuÃ¡rio criado com sucesso.", "user": user})
}

func Login(c* gin.Context) {

	var loginData models.Login

	if err := c.ShouldBindJSON(&loginData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "JSON invÃ¡lido"})
		return
	}

	data, err := services.LoginUser(loginData.Email, loginData.Password)

	if err != nil {
		c.JSON(400, gin.H{"error": err})
	}

	c.JSON(http.StatusOK, gin.H{"message": "UsuÃ¡rio logado com sucesso!", "access_token": data["token"], "user": data["user"]})

}

func Logout(c *gin.Context) {
	// ObtÃ©m o token do cabeÃ§alho Authorization
	authHeader := c.GetHeader("Authorization")
	if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
		c.JSON(http.StatusUnauthorized, gin.H{"message": "Token nÃ£o fornecido"})
		return
	}

	// Extrai o token do cabeÃ§alho
	token := strings.Split(authHeader, " ")[1]

	// Processa o logout em background
	go services.LogoutUser(token)

	c.JSON(http.StatusOK, gin.H{"message": "Logout realizado com sucesso!"})
}

func ForgotPassword(c *gin.Context) {

	var email models.AuthEmailRecovery

	if err := c.ShouldBindJSON(&email); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "JSON invÃ¡lido"})
		return
	}

	forgotPasswordData, err := services.ForgotPasswordService(email.Email) 

	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err})
		return
	}

	if forgotPasswordData["error"] != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": forgotPasswordData["error"]})
		return
	}

	err = services.SendForgotEmailPasswordData(forgotPasswordData)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "CÃ³digo enviado com sucesso!"})
}

func ValidateCode(c *gin.Context) {
	var token models.AuthValidadetToken
	var validateToken string

	if err := c.ShouldBindJSON(&token); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "JSON invÃ¡lido"})
		return
	}

	validateCodeData, err := services.ValidateCodeService(token.Token)

	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Debug para entender a estrutura do validateCodeData
	fmt.Println("validateCodeData:", validateCodeData)

	if validateCodeData["error"] != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": validateCodeData["error"]})
		return
	}

	// Corrigindo a chave do token
	if v, ok := validateCodeData["validated_token"].(string); ok {
		validateToken = v
	} else {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Token invÃ¡lido"})
		return
	}

	err = services.RevokeToken(validateToken)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao revogar token"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":      "CÃ³digo validado com sucesso!",
		"access_token": validateCodeData["access_token"],
	})
}

func ResetPassword(c *gin.Context) {
	var userRecoveryData models.AuthUserResetPassword

	// Bind JSON para a struct
	if err := c.ShouldBindJSON(&userRecoveryData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "JSON invÃ¡lido"})
		return
	}

	// Obter user_id do contexto
	userIDInterface, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "UsuÃ¡rio nÃ£o autenticado"})
		return
	}

	// Converter para string
	userID, ok := userIDInterface.(string)
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao recuperar ID do usuÃ¡rio"})
		return
	}

	// Chamar serviÃ§o para redefinir senha
	resetPasswordData, err := services.ResetPasswordService(userRecoveryData.NewPassword, userRecoveryData.ConfirmPassword, userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao redefinir senha"})
		return
	}

	// Verifica se houve erro na resposta do serviÃ§o
	if errMsg, ok := resetPasswordData["error"].(string); ok && errMsg != "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": errMsg})
		return
	}

	// Resposta de sucesso
	c.JSON(http.StatusOK, gin.H{"message": "Senha atualizada com sucesso!"})
}


============================================================


ðŸ“„ Arquivo : contributors_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/contributors_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"log"
	"net/http"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"

	"github.com/gin-gonic/gin"
)

// Criar um novo colaborador
func CreateContributor(c *gin.Context) {
	var contributorData models.CreateContributor
	if err := c.ShouldBindJSON(&contributorData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"message": "Dados invÃ¡lidos", "error": err.Error()})
		return
	}
	researchId := c.Param("researchId")
	userId := c.Param("userId")

	contributor, err := services.CreateContributor(researchId, userId, contributorData)
	if err != nil {
		log.Println("[CreateContributor] Erro ao criar colaborador:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao criar colaborador", "error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "Colaborador criado com sucesso", "contributor": contributor})
}

// Buscar colaborador por ID
func GetContributorById(c *gin.Context) {
	id := c.Param("id")

	contributor, err := services.GetContributorById(id)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"message": "Colaborador nÃ£o encontrado", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Colaborador encontrado", "contributor": contributor})
}

// Atualizar colaborador por ID
func UpdateContributorById(c *gin.Context) {
	id := c.Param("id")

	var updateData models.UpdateContributor
	if err := c.ShouldBindJSON(&updateData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"message": "Dados invÃ¡lidos", "error": err.Error()})
		return
	}

	contributor, err := services.UpdateContributorById(id, updateData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao atualizar colaborador", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Colaborador atualizado com sucesso", "contributor": contributor})
}

// Deletar colaborador por ID
func DeleteContributorById(c *gin.Context) {
	id := c.Param("id")

	err := services.DeleteContributorById(id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao deletar colaborador", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Colaborador deletado com sucesso"})
}

// Buscar todos os colaboradores de uma pesquisa
func GetAllContributorsByResearchId(c *gin.Context) {
	researchId := c.Param("researchId")

	contributors, err := services.GetAllContributorsByResearchId(researchId)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao buscar colaboradores", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Lista de colaboradores obtida com sucesso", "contributors": contributors})
}

// Buscar colaborador por pesquisa e usuÃ¡rio
func GetContributorByResearchAndUserId(c *gin.Context) {
	researchId := c.Param("researchId")
	userId := c.Param("userId")

	contributor, err := services.GetContributorByResearchAndUserId(researchId, userId)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"message": "Colaborador nÃ£o encontrado", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Colaborador encontrado", "contributor": contributor})
}

// Deletar colaborador por pesquisa e usuÃ¡rio
func DeleteContributorByResearchAndUserId(c *gin.Context) {
	researchId := c.Param("researchId")
	userId := c.Param("userId")

	err := services.DeleteContributorByResearchAndUserId(researchId, userId)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao deletar colaborador", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Colaborador removido com sucesso"})
}


============================================================


ðŸ“„ Arquivo : field_option_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/field_option_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"net/http"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"
	"github.com/gin-gonic/gin"
)

// CreateFieldOption cria uma nova opÃ§Ã£o para um campo
func CreateFieldOption(c *gin.Context) {
	fieldId := c.Param("fieldId")

	var createFieldOptionData models.CreateFieldOption
	if err := c.ShouldBindJSON(&createFieldOptionData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"message": "Dados invÃ¡lidos", "error": err.Error()})
		return
	}

	fieldOption, err := services.CreateFieldOptionService(fieldId, createFieldOptionData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao criar opÃ§Ã£o de campo", "error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "OpÃ§Ã£o criada com sucesso!", "field_option": fieldOption})
}

// GetAllFieldOptionsByFieldId retorna todas as opÃ§Ãµes de um campo
func GetAllFieldOptionsByFieldId(c *gin.Context) {
	fieldId := c.Param("fieldId")

	fieldOptions, err := services.GetAllFieldOptionsByFieldIdService(fieldId)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao buscar opÃ§Ãµes de campo", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Lista de opÃ§Ãµes do campo.", "field_options": fieldOptions})
}

// DeleteFieldOptionById deleta uma opÃ§Ã£o de campo pelo ID
func DeleteFieldOptionById(c *gin.Context) {
	id := c.Param("optionId")
	fieldId := c.Param("fieldId")

	// Criar um canal para capturar erros da goroutine
	errChan := make(chan error, 1)

	// Iniciar uma goroutine para deletar a opÃ§Ã£o de campo
	go func() {
		errChan <- services.DeleteFieldOptionByIdService(id, fieldId)
		close(errChan) // Fecha o canal apÃ³s enviar o erro
	}()

	// Aguardar o resultado da goroutine
	if err := <-errChan; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": "Erro ao deletar a opÃ§Ã£o de campo.",
			"error":   err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "OpÃ§Ã£o de campo deletada com sucesso."})
}


============================================================


ðŸ“„ Arquivo : fields_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/fields_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"net/http"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"
	"net/url"
	"github.com/gin-gonic/gin"
)

// CreateField cria um novo campo em um survey
func CreateField(c *gin.Context) {
	surveyId := c.Param("surveyId")
	
	var createFieldData models.CreateField
	if err := c.ShouldBindJSON(&createFieldData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"message": "Dados invÃ¡lidos", "error": err.Error()})
		return
	}

	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	field, err := services.CreateFieldService(surveyId, surveyType, createFieldData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao criar campo", "error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "Campo criado com sucesso", "field": field})
}

// GetAllFieldsBySurveyId retorna todos os campos de um survey especÃ­fico
func GetAllFieldsBySurveyId(c *gin.Context) {
	surveyId := c.Param("surveyId")

	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	fields, err := services.GetAllFieldsBySurveyIdService(surveyId, surveyType)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao buscar campos", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Campos encontrados", "fields": fields})
}

// DeleteField deleta um campo de um survey
func DeleteField(c *gin.Context) {
	fieldId := c.Param("fieldId")
	surveyId := c.Param("surveyId")

	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	// Criando um canal para capturar erros da goroutine
	errChan := make(chan error, 1)

	// Executando a exclusÃ£o em uma goroutine
	go func() {
		err := services.DeleteFieldBySurveyIdService(fieldId, surveyId, surveyType)
		errChan <- err // Envia erro para o canal (se houver)
		close(errChan) // Fecha o canal apÃ³s o envio do erro
	}()

	// Captura o erro retornado da goroutine
	if err := <-errChan; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao deletar campo", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Campo deletado com sucesso"})
}

// UpdateField atualiza um campo especÃ­fico de um survey
func UpdateField(c *gin.Context) {
	fieldId := c.Param("fieldId")
	surveyId := c.Param("surveyId")
	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	var updateFieldData models.CreateField
	if err := c.ShouldBindJSON(&updateFieldData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"message": "Dados invÃ¡lidos", "error": err.Error()})
		return
	}

	field, err := services.UpdateFieldService(fieldId, surveyId, surveyType, updateFieldData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao atualizar campo", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Campo atualizado com sucesso", "field": field})
}


============================================================


ðŸ“„ Arquivo : input_types_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/input_types_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
    "net/http"
    "placemaking-backend-go/services"

    "github.com/gin-gonic/gin"
)

func GetInputTypes(c *gin.Context) {
	inputTypes, err := services.FetchInputTypes()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch input types"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Lista de tipos de entrada encontrados.","input_types": inputTypes})
}

============================================================


ðŸ“„ Arquivo : research_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/research_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"net/http"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"

	"github.com/gin-gonic/gin"
)

func CreateResearch(c *gin.Context) {
	var createResearchData models.CreateResearch

	if err := c.ShouldBindJSON(&createResearchData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Dados invÃ¡lidos"})
		return
	}

	research, err := services.FetchCreateResearch(createResearchData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao criar pesquisa"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "Pesquisa criada com sucesso!", "research": research})
}

func GetAllResearches(c *gin.Context) {
	researches, err := services.FetchAllResearches()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar pesquisas"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Lista de pesquisas encontradas.", "researches": researches})
}

func GetResearchById(c *gin.Context) {
	id := c.Param("researchId")

	research, err := services.FetchResearchById(id)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Pesquisa nÃ£o encontrada"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Pesquisa encontrada com sucesso.", "research": research})
}

func UpdateResearch(c *gin.Context) {
	id := c.Param("researchId")
	var updateResearchData models.UpdateResearch

	if err := c.ShouldBindJSON(&updateResearchData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Dados invÃ¡lidos"})
		return
	}

	research, err := services.FetchUpdateResearch(id, updateResearchData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao atualizar pesquisa"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Pesquisa atualizada com sucesso.", "research": research})
}

func DeleteResearch(c *gin.Context) {
	id := c.Param("researchId")

	resultChan := make(chan []models.Research, 1)
	errChan := make(chan error, 1)

	go func() {
		deletedResearch, err := services.FetchDeleteResearch(id)
		if err != nil {
			errChan <- err
			return
		}
		resultChan <- deletedResearch
	}()

	select {
	case err := <-errChan:
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao deletar pesquisa", "error": err})
		return
	case deletedResearch := <-resultChan:
		if len(deletedResearch) == 0 {
			c.JSON(http.StatusNotFound, gin.H{"message": "Nenhuma pesquisa encontrada para deletar"})
			return
		}
		c.JSON(http.StatusOK, gin.H{"message": "Pesquisa apagada com sucesso."})
	}
}


============================================================


ðŸ“„ Arquivo : survey_answer_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/survey_answer_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"net/http"
	"net/url"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"

	"github.com/gin-gonic/gin"
)

// POST /surveys/:surveyId/answers
func CreateSurveyAnswer(c *gin.Context) {
	surveyId := c.Param("surveyId")
	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))
	contributorId, _ := url.QueryUnescape(c.Query("contributor_id"))

	var data models.CreateSurveyAnswer
	if err := c.ShouldBindJSON(&data); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Dados invÃ¡lidos"})
		return
	}

	answer, err := services.CreateSurveyAnswer(surveyId, surveyType, contributorId, data)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao criar resposta"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"message": "Resposta criada com sucesso!",
		"answer":  answer,
	})
}

// GET /surveys/:surveyId/answers
func GetSurveyAnswersBySurveyId(c *gin.Context) {
	surveyId := c.Param("surveyId")

	answers, err := services.GetSurveyAnswersBySurveyId(surveyId)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar respostas"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Respostas buscadas com sucesso!",
		"answers": answers,
	})
}

// GET /contributors/:contributorId/answers
func GetSurveyAnswersByContributorId(c *gin.Context) {
	contributorId := c.Param("contributorId")

	answers, err := services.GetSurveyAnswersByContributorId(contributorId)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar respostas"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Respostas do colaborador buscadas com sucesso!",
		"answers": answers,
	})
}

// GET /answers/:id
func GetSurveyAnswerById(c *gin.Context) {
	id := c.Param("answerId")

	answer, err := services.GetSurveyAnswerById(id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar resposta"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Resposta buscada com sucesso!",
		"answer":  answer,
	})
}

// PUT /answers/:id
func UpdateSurveyAnswerById(c *gin.Context) {
	id := c.Param("answerId")

	var data models.UpdateSurveyAnswer
	if err := c.ShouldBindJSON(&data); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Dados invÃ¡lidos"})
		return
	}

	answer, err := services.UpdateSurveyAnswerById(id, data)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao atualizar resposta"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Resposta atualizada com sucesso!",
		"answer":  answer,
	})
}

// DELETE /answers/:id
func DeleteSurveyAnswerById(c *gin.Context) {
	id := c.Param("answerId")

	answer, err := services.DeleteSurveyAnswerById(id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao deletar resposta"})
		return
	}

	if len(answer) == 0 {
		c.JSON(http.StatusNotFound, gin.H{
			"message": "Nenhuma resposta encontrada.",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Resposta deletada com sucesso!",
	})
}


============================================================


ðŸ“„ Arquivo : survey_contributors_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/survey_contributors_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"net/http"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"

	"github.com/gin-gonic/gin"
)

// Criar um novo contribuidor para uma pesquisa
func CreateSurveyContributor(c *gin.Context) {
	var data models.CreateSurveyContributors

	if err := c.ShouldBindJSON(&data); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"message": "Dados invÃ¡lidos", "error": err.Error()})
		return
	}

	id := c.Param("surveyId") // ID vindo da URL

	surveyContributor, err := services.CreateSurveyContributorService(id, data)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao criar contribuidor", "error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "Contribuidor criado com sucesso.","contributor": surveyContributor})
}

// Obter todos os contribuidores de uma pesquisa pelo surveyId
func GetSurveyContributorsBySurveyId(c *gin.Context) {
	surveyId := c.Param("surveyId")

	contributors, err := services.GetSurveyContributorsBySurveyIdService(surveyId)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao buscar contribuidores", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Lista de todos os contribuidores obtida.", "contributors": contributors})
}

// Deletar um contribuidor de uma pesquisa pelo ID e surveyId (assÃ­ncrono)
func DeleteSurveyContributor(c *gin.Context) {
	id := c.Param("contributorId")
	surveyId := c.Param("surveyId")

	// Canal para receber o resultado da goroutine
	errChan := make(chan error, 1)

	// Executa a deleÃ§Ã£o em uma goroutine
	go func() {
		errChan <- services.DeleteSurveyContributorsByIdService(id, surveyId)
	}()

	// Aguarda a resposta da goroutine
	err := <-errChan
	close(errChan)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": "Erro ao deletar contribuidor", "error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Contribuidor deletado com sucesso"})
}



============================================================


ðŸ“„ Arquivo : survey_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/survey_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"log"
	"net/http"
	"net/url"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"

	"github.com/gin-gonic/gin"
)

func CreateSurvey(c *gin.Context) {
	var createSurveyData models.CreateSurvey

	if err := c.ShouldBindJSON(&createSurveyData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"message": "Erro ao processar os dados. Verifique as informaÃ§Ãµes enviadas.",
			"error":   err.Error(),
		})
		return
	}

	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	survey, err := services.CreateSurvey(surveyType, createSurveyData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": "Erro ao criar a pesquisa.",
			"error":   err.Error(),
		})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"message": "Pesquisa criada com sucesso.",
		"survey":  survey,
	})
}

func GetSurveyById(c *gin.Context) {
	id := c.Param("surveyId")
	researchId := c.Param("researchId")

	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	survey, err := services.GetSurveyById(id, researchId, surveyType)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"message": "Pesquisa nÃ£o encontrada.",
			"error":   err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Pesquisa recuperada com sucesso.",
		"survey":  survey,
	})
}

func UpdateSurveyById(c *gin.Context) {
	id := c.Param("surveyId")

	var updateData models.UpdateSurvey
	if err := c.ShouldBindJSON(&updateData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"message": "Erro ao processar os dados. Verifique as informaÃ§Ãµes enviadas.",
			"error":   err.Error(),
		})
		return
	}

	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	survey, err := services.UpdateSurveyById(id, surveyType, updateData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": "Erro ao atualizar a pesquisa.",
			"error":   err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Pesquisa atualizada com sucesso.",
		"survey":  survey,
	})
}

func DeleteSurveyById(c *gin.Context) {
	id := c.Param("surveyId")

	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	_, err := services.DeleteSurveyById(id, surveyType)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": "Erro ao deletar a pesquisa.",
			"error":   err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Pesquisa deletada com sucesso.",
	})
}

func GetSurveysByResearchId(c *gin.Context) {
	researchId := c.Param("researchId")
	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	log.Println(surveyType)

	surveys, err := services.GetSurveysByResearchId(researchId, surveyType)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": "Erro ao buscar pesquisas pelo research_id.",
			"error":   err.Error(),
		})
		return
	}

	if len(surveys) == 0 {
		c.JSON(http.StatusNotFound, gin.H{
			"message": "Nenhuma pesquisa encontrada para o research_id informado.",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Pesquisas recuperadas com sucesso.",
		"surveys": surveys,
	})
}


============================================================


ðŸ“„ Arquivo : survey_group_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/survey_group_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"net/http"
	"net/url"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"

	"github.com/gin-gonic/gin"
)

// Obter todos os grupos de uma pesquisa
func GetSurveyGroups(c *gin.Context) {
	surveyId := c.Param("surveyId")
	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	groups, err := services.GetSurveyGroups(surveyId, surveyType)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": "Erro ao buscar grupos.",
			"error":   err.Error(),
		})
		return
	}

	if len(groups) == 0 {
		c.JSON(http.StatusNotFound, gin.H{
			"message": "Nenhum grupo encontrado.",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Grupos recuperados com sucesso.",
		"groups":  groups,
	})
}

// Criar um novo grupo de pesquisa
func CreateSurveyGroup(c *gin.Context) {
	var groupData models.CreateSurveyGroup
	if err := c.ShouldBindJSON(&groupData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"message": "Dados invÃ¡lidos.",
			"error":   err.Error(),
		})
		return
	}

	surveyId := c.Param("surveyId")

	group, err := services.CreateSurveyGroup(surveyId, groupData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": "Erro ao criar grupo.",
			"error":   err.Error(),
		})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"message": "Grupo criado com sucesso.",
		"group":   group,
	})
}

// Deletar grupo de pesquisa
func DeleteSurveyGroup(c *gin.Context) {
	id := c.Param("groupId")

	err := services.DeleteSurveyGroup(id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"message": "Erro ao deletar grupo.",
			"error":   err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Grupo deletado com sucesso.",
	})
}


============================================================


ðŸ“„ Arquivo : survey_region_controlller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/survey_region_controlller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"net/http"
	"net/url"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"

	"github.com/gin-gonic/gin"
)

// POST /surveys/:surveyId/regions?survey_type=tipo
func CreateSurveyRegion(c *gin.Context) {
	surveyId := c.Param("surveyId")
	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	var regionData models.CreateSurveyRegion
	if err := c.ShouldBindJSON(&regionData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Dados invÃ¡lidos"})
		return
	}

	region, err := services.CreateSurveyRegion(surveyId, surveyType, regionData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao criar regiÃ£o"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"message": "RegiÃ£o de pesquisa criada com sucesso!",
		"region":  region,
	})
}

// GET /surveys/:surveyId/regions
func GetAllSurveyRegionsBySurveyId(c *gin.Context) {
	surveyId := c.Param("surveyId")

	regions, err := services.GetAllSurveyRegionsBySurveyId(surveyId)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar regiÃµes"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "RegiÃµes encontradas com sucesso!",
		"regions": regions,
	})
}

// GET /regions?survey_type=tipo
func GetAllSurveysBySurveyType(c *gin.Context) {
	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	regions, err := services.GetAllSurveysBySurveyType(surveyType)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar regiÃµes por tipo"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "RegiÃµes por tipo encontradas com sucesso!",
		"regions": regions,
	})
}

// GET /regions/:regionId
func GetSurveyRegionById(c *gin.Context) {
	id := c.Param("regionId")

	region, err := services.GetSurveyRegionById(id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar regiÃ£o"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "RegiÃ£o encontrada com sucesso!",
		"region":  region,
	})
}

// PUT /regions/:regionId
func UpdateSurveyRegionById(c *gin.Context) {
	id := c.Param("regionId")

	var data models.UpdateSurveyRegion
	if err := c.ShouldBindJSON(&data); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Dados invÃ¡lidos"})
		return
	}

	updatedRegion, err := services.UpdateSurveyRegion(id, data)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao atualizar regiÃ£o"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "RegiÃ£o atualizada com sucesso!",
		"region":  updatedRegion,
	})
}

// DELETE /regions/:regionId
func DeleteSurveyRegion(c *gin.Context) {
	id := c.Param("regionId")

	deleted, err := services.DeleteSurveyRegion(id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao deletar regiÃ£o"})
		return
	}

	if len(deleted) == 0 {
		c.JSON(http.StatusNotFound, gin.H{
			"message": "Nenhuma regiÃ£o encontrada para deletar.",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "RegiÃ£o deletada com sucesso!",
	})
}


============================================================


ðŸ“„ Arquivo : survey_time_ranges_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/survey_time_ranges_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
	"net/http"
	"net/url"
	"placemaking-backend-go/models"
	"placemaking-backend-go/services"

	"github.com/gin-gonic/gin"
)

// POST /surveys/:surveyId/time-ranges?survey_type=tipo
func CreateSurveyTimeRange(c *gin.Context) {
	surveyId := c.Param("surveyId")
	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	if surveyType == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "survey_type Ã© obrigatÃ³rio"})
		return
	}

	var data models.CreateSurveyTimeRange
	if err := c.ShouldBindJSON(&data); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Dados invÃ¡lidos"})
		return
	}

	timeRange, err := services.CreateSurveyTimeRange(surveyId, surveyType, data)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao criar intervalo de tempo"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"message":     "Intervalo de tempo criado com sucesso!",
		"survey_time": timeRange,
	})
}

// GET /surveys/:surveyId/time-ranges
func GetAllSurveyTimeRangeBySurveyId(c *gin.Context) {
	surveyId := c.Param("surveyId")

	timeRanges, err := services.GetAllSurveyTimeRangeBySurveyId(surveyId)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar intervalos de tempo"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":      "Intervalos de tempo encontrados com sucesso!",
		"survey_times": timeRanges,
	})
}

// GET /time-ranges?survey_type=tipo
func GetAllSurveyTimeRangeBySurveyType(c *gin.Context) {
	surveyType, _ := url.QueryUnescape(c.Query("survey_type"))

	timeRanges, err := services.GetAllSurveyTimeRangeBySurveyType(surveyType)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar intervalos de tempo por tipo"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":      "Intervalos de tempo por tipo encontrados com sucesso!",
		"survey_times": timeRanges,
	})
}

// GET /time-ranges/:timeRangeId
func GetSurveyTimeRangeById(c *gin.Context) {
	id := c.Param("timeRangeId")

	timeRange, err := services.GetSurveyTimeRangeById(id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao buscar intervalo de tempo"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":     "Intervalo de tempo encontrado com sucesso!",
		"survey_time": timeRange,
	})
}

// PUT /time-ranges/:timeRangeId
func UpdateSurveyTimeRangeById(c *gin.Context) {
	id := c.Param("timeRangeId")

	var data models.UpdateSurveyTimeRange
	if err := c.ShouldBindJSON(&data); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Dados invÃ¡lidos"})
		return
	}

	updated, err := services.UpdateSurveyTimeRange(id, data)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao atualizar intervalo de tempo"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":     "Intervalo de tempo atualizado com sucesso!",
		"survey_time": updated,
	})
}

// DELETE /time-ranges/:timeRangeId
func DeleteSurveyTimeRange(c *gin.Context) {
	id := c.Param("timeRangeId")

	deleted, err := services.DeleteSurveyTimeRange(id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao deletar intervalo de tempo"})
		return
	}

	if len(deleted) == 0 {
		c.JSON(http.StatusNotFound, gin.H{
			"message": "Intervalo de tempo nÃ£o encontrado.",
		})
		return
	}
	
	c.JSON(http.StatusOK, gin.H{
		"message":     "Intervalo de tempo deletado com sucesso!",
	})
}


============================================================


ðŸ“„ Arquivo : user_controller.go
ðŸ“‚ Pasta   : controllers
ðŸ§­ Caminho : controllers/user_controller.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package controllers

import (
    "net/http"
    "placemaking-backend-go/services"
	"placemaking-backend-go/models"
    "github.com/gin-gonic/gin"
)

func GetUserById(c *gin.Context) {

	//Pegando Id dos parÃ¢metros da requisiÃ§Ã£o
	id := c.Param("id")

	user, err := services.FetchUserById(id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Falha ao buscar usuÃ¡rio no banco de dados."})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "UsuÃ¡rio encontrado.","user": models.SanitizeUser(user)})
}

func GetAllUsers(c *gin.Context) {

	users, err := services.FetchAllUsers()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Falha ao buscar os usuÃ¡rios no banco de dados"})
	}

	c.JSON(http.StatusOK, gin.H{"message": "UsuÃ¡rios encontrados", "users": users})
}

func DeleteUserById(c *gin.Context) {

	id := c.Param("id")

	err := services.FetchDeleteUser(id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err})
	}

	c.JSON(http.StatusOK, gin.H{"message": "UsuÃ¡rio deletado com sucesso."})
}

func UpdateUserById(c *gin.Context) {
	id := c.Param("id") // Pega o ID da URL

	var user models.User

	// Faz o binding do JSON para a struct User
	if err := c.ShouldBindJSON(&user); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "JSON invÃ¡lido"})
		return
	}

	// Chama o service para atualizar o usuÃ¡rio
	updatedUser, err := services.FetchUpdateUser(id, user)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erro ao atualizar usuÃ¡rio"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"message": "UsuÃ¡rio atualizado com sucesso", "user": models.SanitizeUser(updatedUser)})
}

============================================================


ðŸ“„ Arquivo : database.go
ðŸ“‚ Pasta   : db
ðŸ§­ Caminho : db/database.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package db

import (
	"log"
	"os"
	"github.com/joho/godotenv"
	"github.com/supabase-community/supabase-go"
)

var Supabase *supabase.Client

func InitSupabase() {
	// Pega as variÃ¡veis de ambiente
	err := godotenv.Load()

	if err != nil {
		log.Println("Arquivo .env nÃ£o encontrado, carregando do ambiente")
	}

	supabaseURL := os.Getenv("SUPABASE_URL")
	supabaseKey := os.Getenv("SUPABASE_KEY")

	if supabaseURL == "" || supabaseKey == "" {
		log.Fatal("SUPABASE_URL ou SUPABASE_KEY nÃ£o estÃ£o definidos no .env")
	}

	// Inicializa o cliente do Supabase
	client, err := supabase.NewClient(supabaseURL, supabaseKey, nil)
	if err != nil {
		log.Fatalf("Erro ao conectar ao Supabase: %v", err)
	}

	Supabase = client
}

// FunÃ§Ã£o para acessar o Supabase em outras partes do cÃ³digo
func GetSupabase() *supabase.Client {
	return Supabase
}

============================================================


ðŸ“„ Arquivo : dump_go_structure.sh
ðŸ“‚ Pasta   : .
ðŸ§­ Caminho : dump_go_structure.sh
--------------------------------------
ðŸ“œ ConteÃºdo:

#!/usr/bin/env bash
# ---------------------------------------------------------------------------
# dump_go_structure.sh â€“ Exporta estrutura + conteÃºdo de uma aplicaÃ§Ã£o Go
# ---------------------------------------------------------------------------

set -euo pipefail

ROOT_DIR="$(pwd)"
TIMESTAMP="$(date +'%Y-%m-%d_%H-%M-%S')"
OUTPUT_FILE="${ROOT_DIR}/go_structure_dump_${TIMESTAMP}.txt"

# extensÃµes relevantes para projetos Go
EXTENSIONS=(
  "*.go"
  "*.mod" "*.sum"
  "*.yml" "*.yaml"
  "*.json" "*.env"
  "*.sql"
  "*.sh"
  "*.md"
)

# pastas a excluir do dump
EXCLUDE_DIRS=(
  ".git" "vendor" "bin" "dist" "coverage"
  "node_modules" ".cache" "testdata" "tmp"
)

# cria arquivo de saÃ­da
mkdir -p "$(dirname "$OUTPUT_FILE")"
: > "$OUTPUT_FILE"

cat <<EOF >> "$OUTPUT_FILE"
ðŸ”Ž Dump de Estrutura â€“ Projeto Go
Raiz do projeto : $ROOT_DIR
Gerado em       : $(date)
------------------------------------------------------------

EOF

# monta clÃ¡usula de exclusÃ£o
EXCLUDE_CLAUSE=()
for dir in "${EXCLUDE_DIRS[@]}"; do
  EXCLUDE_CLAUSE+=( -name "$dir" -o )
done
unset 'EXCLUDE_CLAUSE[${#EXCLUDE_CLAUSE[@]}-1]'

# monta clÃ¡usula de extensÃ£o
EXTENSION_CLAUSE=()
for ext in "${EXTENSIONS[@]}"; do
  EXTENSION_CLAUSE+=( -iname "$ext" -o )
done
unset 'EXTENSION_CLAUSE[${#EXTENSION_CLAUSE[@]}-1]'

# executa o find e escreve no dump
find "$ROOT_DIR" \
  \( -type d \( "${EXCLUDE_CLAUSE[@]}" \) -prune \) -o \
  -type f \( "${EXTENSION_CLAUSE[@]}" \) -print0 |
sort -z |
while IFS= read -r -d '' file; do
  filename="$(basename "$file")"
  relative_path="${file#"${ROOT_DIR}/"}"
  folder="$(dirname "$relative_path")"

  {
    echo "ðŸ“„ Arquivo : $filename"
    echo "ðŸ“‚ Pasta   : $folder"
    echo "ðŸ§­ Caminho : $relative_path"
    echo "--------------------------------------"
    echo "ðŸ“œ ConteÃºdo:"
    echo
  } >> "$OUTPUT_FILE"

  if file "$file" | grep -qE 'image|binary|ELF|compressed'; then
    echo "[Arquivo binÃ¡rio / imagem â€“ conteÃºdo omitido]" >> "$OUTPUT_FILE"
  else
    cat "$file" >> "$OUTPUT_FILE"
  fi

  echo -e "\n\n============================================================\n\n" >> "$OUTPUT_FILE"
done

echo "âœ… Estrutura exportada em: $OUTPUT_FILE"


============================================================


ðŸ“„ Arquivo : go.mod
ðŸ“‚ Pasta   : .
ðŸ§­ Caminho : go.mod
--------------------------------------
ðŸ“œ ConteÃºdo:

module placemaking-backend-go

go 1.23.5

require (
	github.com/gin-gonic/gin v1.10.0
	github.com/golang-jwt/jwt/v5 v5.2.2
	github.com/joho/godotenv v1.5.1
	github.com/jordan-wright/email v4.0.1-0.20210109023952-943e75fe5223+incompatible
	github.com/supabase-community/supabase-go v0.0.4
	golang.org/x/crypto v0.36.0
)

require (
	github.com/bytedance/sonic v1.13.2 // indirect
	github.com/bytedance/sonic/loader v0.2.4 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/sse v1.0.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.26.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/kr/pretty v0.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.3 // indirect
	github.com/supabase-community/functions-go v0.0.0-20220927045802-22373e6cb51d // indirect
	github.com/supabase-community/gotrue-go v1.2.0 // indirect
	github.com/supabase-community/postgrest-go v0.0.11 // indirect
	github.com/supabase-community/storage-go v0.7.0 // indirect
	github.com/tomnomnom/linkheader v0.0.0-20180905144013-02ca5825eb80 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	golang.org/x/arch v0.15.0 // indirect
	golang.org/x/net v0.38.0 // indirect
	golang.org/x/sys v0.31.0 // indirect
	golang.org/x/text v0.23.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)


============================================================


ðŸ“„ Arquivo : go.sum
ðŸ“‚ Pasta   : .
ðŸ§­ Caminho : go.sum
--------------------------------------
ðŸ“œ ConteÃºdo:

github.com/bytedance/sonic v1.13.2 h1:8/H1FempDZqC4VqjptGo14QQlJx8VdZJegxs6wwfqpQ=
github.com/bytedance/sonic v1.13.2/go.mod h1:o68xyaF9u2gvVBuGHPlUVCy+ZfmNNO5ETf1+KgkJhz4=
github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
github.com/bytedance/sonic/loader v0.2.4 h1:ZWCw4stuXUsn1/+zQDqeE7JKP+QO47tz7QCNan80NzY=
github.com/bytedance/sonic/loader v0.2.4/go.mod h1:N8A3vUdtUebEY2/VQC0MyhYeKUFosQU6FxH2JmUe6VI=
github.com/cloudwego/base64x v0.1.5 h1:XPciSp1xaq2VCSt6lF0phncD4koWyULpl5bUxbfCyP4=
github.com/cloudwego/base64x v0.1.5/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/gabriel-vasile/mimetype v1.4.8 h1:FfZ3gj38NjllZIeJAmMhr+qKL8Wu+nOoI3GqacKw1NM=
github.com/gabriel-vasile/mimetype v1.4.8/go.mod h1:ByKUIKGjh1ODkGM1asKUbQZOLGrPjydw3hYPU2YU9t8=
github.com/gin-contrib/sse v1.0.0 h1:y3bT1mUWUxDpW4JLQg/HnTqV4rozuW4tC9eFKTxYI9E=
github.com/gin-contrib/sse v1.0.0/go.mod h1:zNuFdwarAygJBht0NTKiSi3jRf6RbqeILZ9Sp6Slhe0=
github.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=
github.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=
github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.26.0 h1:SP05Nqhjcvz81uJaRfEV0YBSSSGMc/iMaVtFbr3Sw2k=
github.com/go-playground/validator/v10 v10.26.0/go.mod h1:I5QpIEbmr8On7W0TktmJAumgzX4CA1XNl4ZmDuVHKKo=
github.com/goccy/go-json v0.10.5 h1:Fq85nIqj+gXn/S5ahsiTlK3TmC85qgirsdTP/+DeaC4=
github.com/goccy/go-json v0.10.5/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=
github.com/golang-jwt/jwt/v5 v5.2.2 h1:Rl4B7itRWVtYIHFrSNd7vhTiz9UpLdi6gZhZ3wEeDy8=
github.com/golang-jwt/jwt/v5 v5.2.2/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/jarcoal/httpmock v1.3.1 h1:iUx3whfZWVf3jT01hQTO/Eo5sAYtB2/rqaUuOtpInww=
github.com/jarcoal/httpmock v1.3.1/go.mod h1:3yb8rc4BI7TCBhFY8ng0gjuLKJNquuDNiPaZjnENuYg=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/jordan-wright/email v4.0.1-0.20210109023952-943e75fe5223+incompatible h1:jdpOPRN1zP63Td1hDQbZW73xKmzDvZHzVdNYxhnTMDA=
github.com/jordan-wright/email v4.0.1-0.20210109023952-943e75fe5223+incompatible/go.mod h1:1c7szIrayyPPB/987hsnvNzLushdWf4o/79s3P08L8A=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
github.com/klauspost/cpuid/v2 v2.2.10 h1:tBs3QSyvjDyFTq3uoc/9xFpCuOsJQFNPiAhYdw2skhE=
github.com/klauspost/cpuid/v2 v2.2.10/go.mod h1:hqwkgyIinND0mEev00jJYCxPNVRVXFQeu1XKlok6oO0=
github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=
github.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=
github.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rogpeppe/go-internal v1.6.1 h1:/FiVV8dS/e+YqF2JvO3yXRFbBLTIuSDkuC7aBOAvL+k=
github.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/supabase-community/functions-go v0.0.0-20220927045802-22373e6cb51d h1:LOrsumaZy615ai37h9RjUIygpSubX+F+6rDct1LIag0=
github.com/supabase-community/functions-go v0.0.0-20220927045802-22373e6cb51d/go.mod h1:nnIju6x3+OZSojtGQCQzu0h3kv4HdIZk+UWCnNxtSak=
github.com/supabase-community/gotrue-go v1.2.0 h1:Zm7T5q3qbuwPgC6xyomOBKrSb7X5dvmjDZEmNST7MoE=
github.com/supabase-community/gotrue-go v1.2.0/go.mod h1:86DXBiAUNcbCfgbeOPEh0PQxScLfowUbYgakETSFQOw=
github.com/supabase-community/postgrest-go v0.0.11 h1:717GTUMfLJxSBuAeEQG2MuW5Q62Id+YrDjvjprTSErg=
github.com/supabase-community/postgrest-go v0.0.11/go.mod h1:cw6LfzMyK42AOSBA1bQ/HZ381trIJyuui2GWhraW7Cc=
github.com/supabase-community/storage-go v0.7.0 h1:cJ8HLbbnL54H5rHPtHfiwtpRwcbDfA3in9HL/ucHnqA=
github.com/supabase-community/storage-go v0.7.0/go.mod h1:oBKcJf5rcUXy3Uj9eS5wR6mvpwbmvkjOtAA+4tGcdvQ=
github.com/supabase-community/supabase-go v0.0.4 h1:sxMenbq6N8a3z9ihNpN3lC2FL3E1YuTQsjX09VPRp+U=
github.com/supabase-community/supabase-go v0.0.4/go.mod h1:SSHsXoOlc+sq8XeXaf0D3gE2pwrq5bcUfzm0+08u/o8=
github.com/tomnomnom/linkheader v0.0.0-20180905144013-02ca5825eb80 h1:nrZ3ySNYwJbSpD6ce9duiP+QkD3JuLCcWkdaehUS/3Y=
github.com/tomnomnom/linkheader v0.0.0-20180905144013-02ca5825eb80/go.mod h1:iFyPdL66DjUD96XmzVL3ZntbzcflLnznH0fr99w5VqE=
github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
github.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=
github.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=
golang.org/x/arch v0.15.0 h1:QtOrQd0bTUnhNVNndMpLHNWrDmYzZ2KDqSrEymqInZw=
golang.org/x/arch v0.15.0/go.mod h1:JmwW7aLIoRUKgaTzhkiEFxvcEiQGyOg9BMonBJUS7EE=
golang.org/x/crypto v0.36.0 h1:AnAEvhDddvBdpY+uR+MyHmuZzzNqXSe/GvuDeob5L34=
golang.org/x/crypto v0.36.0/go.mod h1:Y4J0ReaxCR1IMaabaSMugxJES1EpwhBHhv2bDHklZvc=
golang.org/x/net v0.38.0 h1:vRMAPTMaeGqVhG5QyLJHqNDwecKTomGeqbnfZyKlBI8=
golang.org/x/net v0.38.0/go.mod h1:ivrbrMbzFq5J41QOQh0siUuly180yBYtLp+CKbEaFx8=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=
golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/text v0.23.0 h1:D71I7dUrlY+VX0gQShAThNGHFxZ13dGLBHQLVl1mJlY=
golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/protobuf v1.36.6 h1:z1NpPI8ku2WgiWnf+t9wTPsn6eP1L7ksHUlkfLvd9xY=
google.golang.org/protobuf v1.36.6/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=


============================================================


ðŸ“„ Arquivo : main.go
ðŸ“‚ Pasta   : .
ðŸ§­ Caminho : main.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package handler

import (
	"net/http"
	"placemaking-backend-go/db"
	"placemaking-backend-go/routes"
	"embed"
)

var TemplatesFS embed.FS

func Handler(w http.ResponseWriter, r *http.Request) {
	db.InitSupabase()

	router := routes.SetupRouter()
	router.ServeHTTP(w, r)
}


============================================================


ðŸ“„ Arquivo : jwt.go
ðŸ“‚ Pasta   : middleware
ðŸ§­ Caminho : middleware/jwt.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package middleware

import (
	"fmt"
	"net/http"
	"placemaking-backend-go/config"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
)

// JWTAuthMiddleware valida o JWT e verifica se o token estÃ¡ ativo
func JWTAuthMiddleware(publicRoutes map[string]bool) gin.HandlerFunc {
	return func(c *gin.Context) {
		method := c.Request.Method
		path := c.FullPath()
		routeKey := fmt.Sprintf("%s %s", method, path)

		// Se a rota for pÃºblica, permite a requisiÃ§Ã£o sem autenticaÃ§Ã£o
		if publicRoutes[routeKey] {
			c.Next()
			return
		}

		// Caso contrÃ¡rio, exige autenticaÃ§Ã£o
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Token nÃ£o fornecido"})
			c.Abort()
			return
		}

		tokenString := strings.Split(authHeader, " ")[1]
		claims := &jwt.MapClaims{}

		token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(config.LoadSettings().JwtSecret), nil
		})

		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Token invÃ¡lido"})
			c.Abort()
			return
		}

		// Verifica se o token expirou
		exp, ok := (*claims)["exp"].(float64)
		if !ok {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Formato do token invÃ¡lido"})
			c.Abort()
			return
		}

		expirationTime := time.Unix(int64(exp), 0)
		if expirationTime.Before(time.Now()) {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Token expirado"})
			c.Abort()
			return
		}

		// ObtÃ©m o ID do usuÃ¡rio do token
		var userID string
		if sub, ok := (*claims)["sub"].(string); ok {
			userID = sub
		} else {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Token sem ID de usuÃ¡rio"})
			c.Abort()
			return
		}

		// Salva o ID do usuÃ¡rio no contexto
		c.Set("user_id", userID)
		c.Next()
	}
}


============================================================


ðŸ“„ Arquivo : Auth.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/Auth.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type AuthEmailRecovery struct {
	Email string `json:"email"`
}

type AuthValidadetToken struct {
	Token string `json:"token"`
}

type AuthUserResetPassword struct {
	NewPassword string `json:"new_password"`
	ConfirmPassword string `json:"confirm_password"`
}


============================================================


ðŸ“„ Arquivo : Contributors.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/Contributors.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type Contributor struct {
	ID          string `json:"id"`
	ResearchId  string `json:"research_id"`
	UserId      string `json:"user_id"`
	Instruction string `json:"instruction"`
}

type ViewContributor struct {
	ID          string        `json:"id"`
	ResearchId  string        `json:"research_id"`
	UserId      string        `json:"user_id"`
	Instruction string        `json:"instruction"`
	User        SanitizedUser `json:"user"`
}

type CreateContributor struct {
	Instruction string `json:"instruction"`
}

type UpdateContributor struct {
	Instruction string `json:"instruction"`
}


============================================================


ðŸ“„ Arquivo : Email.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/Email.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type EmailData struct {
	Name         string `json:"name"`
	TempPassword string `json:"temp_password"`
}

type RecoveryEmailData struct {
	Name  string `json:"name"`
	Token string `json:"token"`
}


============================================================


ðŸ“„ Arquivo : Field_option.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/Field_option.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type FieldOption struct {
	ID          string `json:"id"`
	FieldId     string `json:"field_id"`
	OptionText  string `json:"option_text"`
	CreatedAt   string `json:"created_at"`
	UpdatedAt   string `json:"updated_at"`
	OptionValue string `json:"option_value"`
}

type CreateFieldOption struct {
	OptionText  string `json:"option_text"`
	OptionValue string `json:"option_value"`
}

============================================================


ðŸ“„ Arquivo : Fields.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/Fields.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type Field struct {
	ID          string `json:"id"`
	Title       string `json:"title"`
	Description string `json:"description"`
	InputTypeId string `json:"input_type_id"`
	SurveyType  string `json:"survey_type"`
	SurveyId    string `json:"survey_id"`
}

type CreateField struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	InputTypeId string `json:"input_type_id"`
}


============================================================


ðŸ“„ Arquivo : InputType.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/InputType.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type InputType struct {
	ID        string   `json:"id"`
	Name      string `json:"name"`
	Stored_As string `json:"stored_as"`
}

============================================================


ðŸ“„ Arquivo : Logs.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/Logs.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type Logs struct {
	ID          string      `json:"id"`
	UserId      string      `json:"user_id"`
	Action      string      `json:"action"`
	Description string      `json:"description"`
	Data        interface{} `json:"data"`
	CreatedAt   string      `json:"created_at"`
}

type CreateLogs struct {
	UserId      string      `json:"user_id"`
	Action      string      `json:"action"`
	Description string      `json:"description"`
	Data        interface{} `json:"data"`
}


============================================================


ðŸ“„ Arquivo : Research.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/Research.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type CreateResearch struct {
	Title         string  `json:"title"`
	Description   string  `json:"description"`
	ReleaseDate   string  `json:"release_date"`
	CreatedBy     string  `json:"created_by"`
	Lat           float32 `json:"lat"`
	Long          float32 `json:"long"`
	LocationTitle string  `json:"location_title"`
	EndDate       string  `json:"end_date"`
}

type Research struct {
	Id            string  `json:"id"`
	Title         string  `json:"title"`
	Description   string  `json:"description"`
	ReleaseDate   string  `json:"release_date"`
	CreatedBy     string  `json:"created_by"`
	Lat           float32 `json:"lat"`
	Long          float32 `json:"long"`
	LocationTitle string  `json:"location_title"`
	EndDate       string  `json:"end_date"`
}

type ViewResearch struct {
	Id            string        `json:"id"`
	Title         string        `json:"title"`
	Description   string        `json:"description"`
	ReleaseDate   string        `json:"release_date"`
	CreatedBy     SanitizedUser `json:"created_by"`
	Lat           float32       `json:"lat"`
	Long          float32       `json:"long"`
	LocationTitle string        `json:"location_title"`
	EndDate       string        `json:"end_date"`
}

type UpdateResearch struct {
	Title         string  `json:"title"`
	Description   string  `json:"description"`
	ReleaseDate   string  `json:"release_date"`
	Lat           float32 `json:"lat"`
	Long          float32 `json:"long"`
	LocationTitle string  `json:"location_title"`
	EndDate       string  `json:"end_date"`
}


============================================================


ðŸ“„ Arquivo : Survey.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/Survey.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type Survey struct {
	ID            string  `json:"id"`
	Title         string  `json:"title"`
	Description   string  `json:"description"`
	Lat           float32 `json:"lat"`
	Long          float32 `json:"long"`
	LocationTitle string  `json:"location_title"`
	ResearchId    string  `json:"research_id"`
}

type CreateSurvey struct {
	Title         string  `json:"title"`
	Description   string  `json:"description"`
	Lat           float32 `json:"lat"`
	Long          float32 `json:"long"`
	LocationTitle string  `json:"location_title"`
	ResearchId    string  `json:"research_id"`
}

type UpdateSurvey struct {
	Title         string  `json:"title"`
	Description   string  `json:"description"`
	Lat           float32 `json:"lat"`
	Long          float32 `json:"long"`
	LocationTitle string  `json:"location_title"`
}

type SurveyType struct {
	Type string `json:"survey_type"`
}

============================================================


ðŸ“„ Arquivo : SurveyAnswer.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/SurveyAnswer.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type SurveyAnswer struct {
	ID                string  `json:"id"`
	Value             string  `json:"value"`
	SurveyType        string  `json:"survey_type"`
	SurveyId          string  `json:"survey_id"`
	SurveyGroupId     *string `json:"survey_group_id"`
	ContributorId     string  `json:"contributor_id"`
	RegisteredAt      string  `json:"registered_at"`
	SurveyTimeRangeId string  `json:"survey_time_range_id"`
	SurveyRegionId    string  `json:"survey_region_id"`
}

type CreateSurveyAnswer struct {
	Value             string  `json:"value"`
	SurveyGroupId     *string `json:"survey_group_id"`
	SurveyTimeRangeId string  `json:"survey_time_range_id"`
	RegisteredAt      string  `json:"registered_at"`
	SurveyRegionId    string  `json:"survey_region_id"`
}

type UpdateSurveyAnswer struct {
	Value             string  `json:"value"`
	SurveyGroupId     *string `json:"survey_group_id"`
	SurveyTimeRangeId string  `json:"survey_time_range_id"`
	RegisteredAt      string  `json:"registered_at"`
	SurveyRegionId    string  `json:"survey_region_id"`
}


============================================================


ðŸ“„ Arquivo : SurveyContributors.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/SurveyContributors.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type SurveyContributors struct {
	ID          string `json:"id"`
	SurveyId    string `json:"survey_id"`
	SurveyType  string `json:"survey_type"`
	UserId      string `json:"user_id"`
	Instruction string `json:"instruction"`
	CreatedAt   string `json:"created_at"`
	UpdatedAt   string `json:"updated_at"`
}

type CreateSurveyContributors struct {
	SurveyType  string `json:"survey_type"`
	UserId      string `json:"user_id"`
	Instruction string `json:"instruction"`
}


============================================================


ðŸ“„ Arquivo : SurveyGroup.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/SurveyGroup.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type SurveyGroup struct {
	ID         string `json:"id"`
	SurveyId   string `json:"survey_id"`
	SurveyType string `json:"survey_type"`
}

type CreateSurveyGroup struct {
	SurveyType string `json:"survey_type"`
}


============================================================


ðŸ“„ Arquivo : SurveyRegion.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/SurveyRegion.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type SurveyRegion struct {
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	LocationTitle string  `json:"location_title"`
	Lat           float32 `json:"lat"`
	Long          float32 `json:"long"`
	SurveyId      string  `json:"survey_id"`
	SurveyType    string  `json:"survey_type"`
}

type CreateSurveyRegion struct {
	Name          string  `json:"name"`
	Lat           float32 `json:"lat"`
	Long          float32 `json:"long"`
	LocationTitle string  `json:"location_title"`
}

type UpdateSurveyRegion struct {
	Name          string  `json:"name"`
	LocationTitle string  `json:"location_title"`
	Lat           float32 `json:"lat"`
	Long          float32 `json:"long"`
}


============================================================


ðŸ“„ Arquivo : SurveyTimeRange.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/SurveyTimeRange.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type SurveyTimeRange struct {
	ID         string `json:"id"`
	SurveyId   string `json:"survey_id"`
	SurveyType string `json:"survey_type"`
	StartTime  string `json:"start_time"`
	EndTime    string `json:"end_time"`
}

type CreateSurveyTimeRange struct {
	StartTime  string `json:"start_time"`
	EndTime    string `json:"end_time"`
}

type UpdateSurveyTimeRange struct {
	StartTime  string `json:"start_time"`
	EndTime    string `json:"end_time"`
}


============================================================


ðŸ“„ Arquivo : Token.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/Token.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

type Token struct {
	ID         string    `json:"id"`
	User_id    string    `json:"user_id"`
	Token      string    `json:"token"`
	TokenType  string    `json:"token_type"`
	Active     bool      `json:"active"`
	Created_at string `json:"created_at"`
	Updated_at string `json:"updated_at"`
	Expires_at string `json:"expires_at"`
}

// SanitizedToken representa o token sem informaÃ§Ãµes sensÃ­veis.
type SanitizedToken struct {
	Token     string `json:"token"`
	TokenType string `json:"token_type"`
	ExpiresAt string `json:"expires_at"`
	CreatedAt string `json:"created_at"`
}

// SanitizeToken formata os timestamps corretamente e retorna um token seguro.
func SanitizeToken(token Token) SanitizedToken {
	return SanitizedToken{
		Token:     token.Token,
		TokenType: token.TokenType,
		ExpiresAt: token.Expires_at,
		CreatedAt: token.Created_at,
	}
}


============================================================


ðŸ“„ Arquivo : User.go
ðŸ“‚ Pasta   : models
ðŸ§­ Caminho : models/User.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package models

import (
	"log"
	"placemaking-backend-go/utils"
)

type Login struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type User struct {
	ID         string `json:"id"`
	Name       string `json:"name"`
	Email      string `json:"email"`
	Password   string `json:"password"`
	Role       string `json:"role"`
	Created_at string `json:"created_at"`
	Updated_at string `json:"updated_at"`
	Status     string `json:"status"`
}

type CreateUser struct {
	Name         string `json:"name"`
	Email        string `json:"email"`
	ConfirmEmail string `json:"confirmation_email"`
	Role         string `json:"role"`
	Status       string `json:"status"`
}

type InsertUser struct {
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
	Role     string `json:"role"`
	Status   string `json:"status"`
}

// SanitizedUser remove a senha antes de retornar os dados do usuÃ¡rio.
type SanitizedUser struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Email     string `json:"email"`
	Role      string `json:"role"`
	CreatedAt string `json:"created_at"`
	UpdatedAt string `json:"updated_at"`
	Status    string `json:"status"`
}

// SanitizeUser cria um novo objeto sem a senha.
func SanitizeUser(user User) SanitizedUser {
	return SanitizedUser{
		ID:        user.ID,
		Name:      user.Name,
		Email:     user.Email,
		Role:      user.Role,
		CreatedAt: user.Created_at,
		UpdatedAt: user.Updated_at,
		Status:    user.Status,
	}
}

// MÃ©todo para converter as strings em time.Time
func (u *User) ConvertTimestamps() {
	var err error
	u.Created_at, err = utils.ParseTimestamp(u.Created_at)
	if err != nil {
		log.Println("Erro ao converter CreatedAt:", err)
	}

	u.Updated_at, err = utils.ParseTimestamp(u.Updated_at)
	if err != nil {
		log.Println("Erro ao converter UpdatedAt:", err)
	}
}


============================================================


ðŸ“„ Arquivo : contributors_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/contributors_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"log"
	"fmt"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func CreateContributor(researchId, userId string, contributorData models.CreateContributor) (models.Contributor, error) {
	supabase := db.GetSupabase()

	var contributor models.Contributor

	// Criando um mapa para representar o colaborador
	newContributor := map[string]interface{}{
		"user_id":     userId,
		"research_id": researchId,
		"instruction": contributorData.Instruction,
	}

	// Inserindo no banco de dados
	_, err := supabase.From("research_contributors").
	Insert(newContributor, false, "", "", "").
	Single().
	ExecuteTo(&contributor)

	if err != nil {
		log.Println("[CreateContributor] Erro ao criar colaborador:", err)
		return models.Contributor{}, err
	}

	return contributor, nil
}

func GetContributorById(id string) (models.Contributor, error) {
	supabase := db.GetSupabase()

	var contributor models.Contributor

	_, err := supabase.From("research_contributors").
	Select("*","", false).
	Eq("id", id).
	Single().
	ExecuteTo(&contributor)

	if err != nil {
		log.Println("[GetContributorById] Erro ao buscar colaborador:", err)
		return models.Contributor{}, err
	}

	return contributor, nil
}

func UpdateContributorById(id string, updateData models.UpdateContributor) (models.Contributor, error){
	supabase := db.GetSupabase()

	var contributor models.Contributor

	// Criando um mapa para representar o colaborador
	newContributor := map[string]interface{}{
		"instruction": updateData.Instruction,
	}

	// Atualizando no banco de dados
	_, err := supabase.From("research_contributors").
	Update(newContributor,"","").
	Single().
	ExecuteTo(&contributor)

	if err != nil {
		log.Println("[UpdateContributorById] Erro ao atualizar contribuidor:", err)
		return models.Contributor{}, err
	}

	return contributor, nil
}

func DeleteContributorById(id string) error {
	supabase := db.GetSupabase()

	var existingContributors []models.Contributor

	// Verificar se o colaborador existe no banco
	_, err := supabase.From("research_contributors").
		Select("*", "", false).
		Eq("id", id).
		ExecuteTo(&existingContributors)

	if err != nil {
		log.Println("[DeleteContributorById] Erro ao buscar contribuidor:", err)
		return err
	}

	// Se nÃ£o existir, retorna um erro
	if len(existingContributors) == 0 {
		return fmt.Errorf("colaborador nÃ£o encontrado")
	}

	// Se existir, deleta o colaborador
	_, _, err = supabase.From("research_contributors").
		Delete("", "").
		Eq("id", id).
		Execute()

	if err != nil {
		log.Println("[DeleteContributorById] Erro ao deletar contribuidor no banco:", err)
		return err
	}

	return nil
}


func GetAllContributorsByResearchId(researchId string) ([]models.Contributor, error) {
	supabase := db.GetSupabase()

	var contributors []models.Contributor

	_, err := supabase.From("research_contributors").
	Select("*", "", false).
	Eq("research_id", researchId).
	ExecuteTo(&contributors)

	if err != nil {
		log.Println("[GetAllContributorsByResearchId] Erro ao buscar contribuidores no banco:", err)
		return []models.Contributor{}, err
	}

	return contributors, nil
}

func GetContributorByResearchAndUserId(researchId, userId string) (models.Contributor, error) {
	supabase := db.GetSupabase()

	var contributor models.Contributor

	_, err := supabase.From("research_contributors").
	Select("*", "", false).
	Eq("research_id", researchId).
	Eq("user_id", userId).
	Single().
	ExecuteTo(&contributor)

	if err != nil {
		log.Println("[GetContributorByResearchAndUserId] Erro ao buscar contribuidor no banco:", err)
		return models.Contributor{}, err
	}

	return contributor, nil
}

func DeleteContributorByResearchAndUserId(researchId, userId string) error {
	supabase := db.GetSupabase()

	var existingContributors []models.Contributor

	// Verificar se o colaborador existe no banco
	_, err := supabase.From("research_contributors").
		Select("*", "", false).
		Eq("research_id", researchId).
		Eq("user_id", userId).
		ExecuteTo(&existingContributors)

	if err != nil {
		log.Println("[DeleteContributorByResearchAndUserId] Erro ao buscar contribuidor:", err)
		return err
	}

	// Se nÃ£o existir, retorna um erro
	if len(existingContributors) == 0 {
		return fmt.Errorf("colaborador nÃ£o encontrado")
	}

	// Se existir, deleta o colaborador
	_, _, err = supabase.From("research_contributors").
		Delete("", "").
		Eq("research_id", researchId).
		Eq("user_id", userId).
		Execute()

	if err != nil {
		log.Println("[DeleteContributorByResearchAndUserId] Erro ao deletar contribuidor no banco:", err)
		return err
	}

	return nil
}


============================================================


ðŸ“„ Arquivo : field_option_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/field_option_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"log"
	"errors"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func CreateFieldOption(fieldId string, createFieldOptionData models.CreateFieldOption) (models.FieldOption, error) {
	supabase := db.GetSupabase()

	// Criando um mapa com os dados para inserÃ§Ã£o
	newFieldOption := map[string]interface{}{
		"field_id":     fieldId,
		"option_text":  createFieldOptionData.OptionText,
		"option_value": createFieldOptionData.OptionValue,
	}

	var fieldOption models.FieldOption

	_, err := supabase.From("field_options").
		Insert(newFieldOption, false, "", "", "").
		Single().
		ExecuteTo(&fieldOption)

	if err != nil {
		log.Println("[CreateFieldOption] Erro ao criar opÃ§Ã£o de campo:", err)
		return models.FieldOption{}, err
	}

	return fieldOption, nil
}

func GetAllFieldOptionsByFieldId(fieldId string) ([]models.FieldOption, error) {
	supabase := db.GetSupabase()

	var fieldOptions []models.FieldOption

	_, err := supabase.From("field_options").
		Select("*", "", false).
		Eq("field_id", fieldId).
		ExecuteTo(&fieldOptions)

	if err != nil {
		log.Println("[GetAllFieldOptionsByFieldId] Erro ao buscar opÃ§Ãµes de campo:", err)
		return nil, err
	}

	return fieldOptions, nil
}

func DeleteFieldOptionById(id, fieldId string) error {
	supabase := db.GetSupabase()

	var deletedField []models.FieldOption

	_, err := supabase.From("field_options").
		Delete("", "").
		Eq("id", id).
		Eq("field_id", fieldId).
		ExecuteTo(&deletedField)

	if err != nil {
		log.Println("[DeleteFieldOptionById] Erro ao deletar opÃ§Ã£o de campo:", err)
		return err
	}

	if len(deletedField) == 0 { // Verifica se o Supabase retornou algo
		log.Println("[DeleteFieldOptionById] Nenhuma opÃ§Ã£o de campo encontrada para deletar")
		return errors.New("nenhum campo encontrado para os critÃ©rios fornecidos")
	}

	return nil
}

============================================================


ðŸ“„ Arquivo : fields_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/fields_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"errors"
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func CreateField(surveyId, surveyType string, createFieldData models.CreateField) (models.Field, error) {
	supabase := db.GetSupabase()

	var field models.Field

	// Criando um novo field com os dados recebidos
	data := map[string]interface{}{
		"title":         createFieldData.Title,
		"description":   createFieldData.Description,
		"input_type_id": createFieldData.InputTypeId,
		"survey_id":     surveyId,
		"survey_type":   surveyType,
	}

	_, err := supabase.From("fields").
		Insert(data, false, "", "", "").
		Single().
		ExecuteTo(&field)

	if err != nil {
		log.Println("[CreateField] Erro ao criar campo:", err)
		return models.Field{}, err
	}

	return field, nil
}

func GetAllFieldsBySurveyId(surveyId, surveyType string) ([]models.Field, error) {
	supabase := db.GetSupabase()

	var fields []models.Field

	_, err := supabase.From("fields").
		Select("*", "", false).
		Eq("survey_id", surveyId).
		Eq("survey_type", surveyType).
		ExecuteTo(&fields)

	if err != nil {
		log.Println("[GetAllFieldsBySurveyId] Erro ao buscar campos:", err)
		return []models.Field{}, err
	}

	return fields, nil
}

func DeleteFieldBySurveyId(id, surveyId, surveyType string) error {
	supabase := db.GetSupabase()

	// Executa a operaÃ§Ã£o de exclusÃ£o e retorna os registros afetados
	var deletedRecords []models.Field
	_, err := supabase.From("fields").
		Delete("", "").
		Eq("id", id).
		Eq("survey_id", surveyId).
		Eq("survey_type", surveyType).
		ExecuteTo(&deletedRecords)

	if err != nil {
		log.Println("[DeleteFieldBySurveyId] Erro ao deletar campo:", err)
		return err
	}

	// Verifica se algum registro foi deletado
	if len(deletedRecords) == 0 {
		log.Println("[DeleteFieldBySurveyId] Nenhum campo encontrado para os critÃ©rios fornecidos.")
		return errors.New("nenhum campo encontrado para os critÃ©rios fornecidos")
	}

	log.Println("[DeleteFieldBySurveyId] Campo deletado com sucesso.")
	return nil
}

func UpdateField(id, surveyId, surveyType string, updateFieldData models.CreateField) (models.Field, error) {
	supabase := db.GetSupabase()

	var field models.Field

	// Atualizando field com os dados recebidos
	data := map[string]interface{}{
		"title":         updateFieldData.Title,
		"description":   updateFieldData.Description,
		"input_type_id": updateFieldData.InputTypeId,
	}

	_, err := supabase.From("fields").
		Update(data, "", "").
		Eq("id", id).
		Eq("survey_id", surveyId).
		Eq("survey_type", surveyType).
		Single().
		ExecuteTo(&field)

	if err != nil {
		log.Println("[Update] Erro ao atualizar campo:", err)
		return models.Field{}, err
	}

	return field, nil
}

============================================================


ðŸ“„ Arquivo : input_type_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/input_type_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"encoding/json"
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func GetAllInputTypes() ([]models.InputType, error) {
	supabase := db.GetSupabase()

	// Executar a query para buscar todos os input_types
	response, _, err := supabase.From("input_types").Select("*", "", false).Execute()
	if err != nil {
		log.Println("Error fetching input types:", err)
		return nil, err
	}

	// Converter JSON para struct
	var inputTypes []models.InputType

	if err = json.Unmarshal(response, &inputTypes); err != nil {
		log.Println("Error decoding input types:", err)
		return nil, err
	}

	return inputTypes, nil
}


============================================================


ðŸ“„ Arquivo : research_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/research_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
	"time"
)

func CreateResearch(createResearchData models.CreateResearch) (models.Research, error){

	supabase := db.GetSupabase()

	var research models.Research

	// InserÃ§Ã£o no banco de dados
	_, err := supabase.From("research").Insert(map[string]interface{}{
		"title":          createResearchData.Title,
		"description":    createResearchData.Description,
		"release_date":   createResearchData.ReleaseDate,
		"created_by":     createResearchData.CreatedBy,
		"lat":            createResearchData.Lat,
		"long":           createResearchData.Long,
		"location_title": createResearchData.LocationTitle,
		"end_date":       createResearchData.EndDate,
	}, false, "", "", "").Single().ExecuteTo(&research)

	if err != nil {
		return models.Research{}, err
	}

	return research, nil
}

func GetAllResearches() ([]models.Research, error) {
	supabase := db.GetSupabase()

	var researches []models.Research

	_, err := supabase.From("research").
		Select("*", "", false).
		ExecuteTo(&researches)

	if err != nil {
		log.Println("Erro ao buscar pesquisas:", err)
		return nil, err
	}

	return researches, nil
}

func GetResearchById(id string) (models.Research, error) {
	supabase := db.GetSupabase()

	var research models.Research

	_, err := supabase.From("research").
		Select("*", "", false).
		Single().
		Eq("id", id).
		ExecuteTo(&research)

	if err != nil {
		log.Println("Erro ao buscar pesquisas:", err)
		return models.Research{}, err
	}

	return research, nil

}

func UpdateResearchById(id string, updateResearchData models.UpdateResearch) (models.Research, error) {
	supabase := db.GetSupabase()

	updatedData := map[string]interface{}{
		"title":          updateResearchData.Title,
		"description":    updateResearchData.Description,
		"release_date":   updateResearchData.ReleaseDate,
		"end_date":       updateResearchData.EndDate,
		"lat":            updateResearchData.Lat,
		"long":           updateResearchData.Long,
		"location_title": updateResearchData.LocationTitle,
		"updated_at":     time.Now(), // Atualiza a data de modificaÃ§Ã£o
	}

	var research models.Research

	_, err := supabase.From("research").
		Update(updatedData, "", ""). // Atualiza os dados no Supabase
		Eq("id", id).                // Filtra pelo ID
		Single().
		ExecuteTo(&research) // Decodifica para a struct Research

	if err != nil {
		log.Println("Erro ao atualizar pesquisa:", err)
		return models.Research{}, err
	}

	return research, nil
}

func DeleteResearchById(id string) ([]models.Research, error) {
	supabase := db.GetSupabase()

	var deletedResearch []models.Research

	_, err := supabase.From("research").
		Delete("","").
		Eq("id", id).
		ExecuteTo(&deletedResearch)

	if err != nil {
		log.Println("Erro ao deletar pesquisa:", err)
		return deletedResearch, err
	}

	return deletedResearch, nil
}


============================================================


ðŸ“„ Arquivo : survey_answer_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/survey_answer_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func CreateSurveyAnswer(surveyId, surveyType, contributorId string, surveyAnswerData models.CreateSurveyAnswer) (models.SurveyAnswer, error) {
	supabase := db.GetSupabase()

	// Convertendo para map[string]interface{}
	insertData := map[string]interface{}{
		"value":      surveyAnswerData.Value,
		"survey_id":   surveyId,
		"survey_type": surveyType,
		"contributor_id": contributorId,
		"registered_at": surveyAnswerData.RegisteredAt,
		"survey_group_id": surveyAnswerData.SurveyGroupId,
		"survey_time_range_id": surveyAnswerData.SurveyTimeRangeId,
		"survey_region_id": surveyAnswerData.SurveyRegionId,
	}

	var createdSurveyAnswer models.SurveyAnswer

	_, err := supabase.
		From("survey_answers").
		Insert(insertData, false, "", "", "").
		Single().
		ExecuteTo(&createdSurveyAnswer)

	if err != nil {
		log.Println("[CreateSurveyAnswer] Erro ao criar resposta de pesquisa no banco de dados:", err)
		return models.SurveyAnswer{}, err
	}

	return createdSurveyAnswer, nil

}

func GetAllSurveyAnswersBySurveyId(surveyId string) ([]models.SurveyAnswer, error) {
	supabase := db.GetSupabase()

	var surveyAnswers []models.SurveyAnswer

	_, err := supabase.From("survey_answers").
		Select("*", "", false).
		Eq("survey_id", surveyId).
		ExecuteTo(&surveyAnswers)

	if err != nil {
		log.Println("[GetAllSurveyAnswersBySurveyId] Erro ao buscar respostas de pesquisa no banco de dados:", err)
		return []models.SurveyAnswer{}, err
	}

	return surveyAnswers, nil

}

func GetAllAnswersByContributorId(contributorId string) ([]models.SurveyAnswer, error) {
	supabase := db.GetSupabase()

	var surveyAnswers []models.SurveyAnswer

	_, err := supabase.From("survey_answers").
		Select("*", "", false).
		Eq("contributor_id", contributorId).
		ExecuteTo(&surveyAnswers)

	if err != nil {
		log.Println("[GetAllAnswersByContributorId] Erro ao buscar respostas de pesquisa no banco de dados:", err)
		return []models.SurveyAnswer{}, err
	}

	return surveyAnswers, nil

}

func GetSurveyAnswerById(id string) (models.SurveyAnswer, error) {
	supabase := db.GetSupabase()

	var surveyAnswer models.SurveyAnswer

	_, err := supabase.From("survey_answers").
		Select("*", "", false).
		Eq("id", id).
		Single().
		ExecuteTo(&surveyAnswer)

	if err != nil {
		log.Println("[GetSurveyAnswerById] Erro ao buscar resposta de pesquisa no banco de dados:", err)
		return models.SurveyAnswer{}, err
	}

	return surveyAnswer, nil

}

func DeleteSurveyAnswerById(id string) ([]models.SurveyAnswer, error) {
	supabase := db.GetSupabase()

	var deletedAnswers []models.SurveyAnswer

	_, err := supabase.From("survey_answers").
		Delete("","").
		Eq("id", id).
		ExecuteTo(&deletedAnswers)

	if err != nil {
		log.Println("[DeleteSurveyAnswerById] Erro ao deletar resposta de pesquisa no banco de dados:", err)
		return deletedAnswers, err
	}

	return deletedAnswers, nil
}

func UpdateSurveyAnswerById(id string, surveyAnswerData models.UpdateSurveyAnswer) (models.SurveyAnswer, error) {
	supabase := db.GetSupabase()

	// Convertendo para map[string]interface{}
	updateData := map[string]interface{}{
		"value":      surveyAnswerData.Value,
		"registered_at": surveyAnswerData.RegisteredAt,
		"survey_group_id": surveyAnswerData.SurveyGroupId,
		"survey_time_range_id": surveyAnswerData.SurveyTimeRangeId,
		"survey_region_id": surveyAnswerData.SurveyRegionId,
	}

	var updatedSurveyAnswer models.SurveyAnswer

	_, err := supabase.
		From("survey_answers").
		Update(updateData, "", "").
		Eq("id", id).
		Single().
		ExecuteTo(&updatedSurveyAnswer)

	if err != nil {
		log.Println("[UpdateSurveyAnswerById] Erro ao atualizar resposta de pesquisa no banco de dados:", err)
		return models.SurveyAnswer{}, err
	}

	return updatedSurveyAnswer, nil

}

============================================================


ðŸ“„ Arquivo : survey_contributors_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/survey_contributors_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"errors"
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func CreateSurveyContributors(surveyId string, createSurveyContributorData models.CreateSurveyContributors) (models.SurveyContributors, error) {
	supabase := db.GetSupabase()

	// Criando o mapa com os dados para inserÃ§Ã£o
	new_data := map[string]interface{}{
		"survey_id":   surveyId,
		"survey_type": createSurveyContributorData.SurveyType,
		"user_id":     createSurveyContributorData.UserId,
		"instruction": createSurveyContributorData.Instruction,
	}

	var surveyContributor models.SurveyContributors

	// Inserindo no banco de dados
	_, err := supabase.From("survey_contributors").
		Insert(new_data, false, "", "", "").
		Single().
		ExecuteTo(&surveyContributor)

	if err != nil {
		return models.SurveyContributors{}, err
	}

	return surveyContributor, nil
}

func GetSurveyContributorsBySurveyId(surveyId string) ([]models.SurveyContributors, error) {
	supabase := db.GetSupabase()

	var surveyContributors []models.SurveyContributors

	_, err := supabase.From("survey_contributors").
		Select("*", "", false).
		Eq("survey_id", surveyId).
		ExecuteTo(&surveyContributors)

	if err != nil {
		log.Println("[GetSurveyContributorsBySurveyId] Erro ao buscar contribuidores.", err)
		return []models.SurveyContributors{}, err
	}

	return surveyContributors, nil
}

func DeleteSurveyContributorsById(id, surveyId string) error {
	supabase := db.GetSupabase()

	var deletedContributor []models.SurveyContributors

	_, err := supabase.From("survey_contributors").
		Delete("", "").
		Eq("id", id).
		Eq("survey_id", surveyId).
		ExecuteTo(&deletedContributor)

	if err != nil {
		log.Println("[DeleteSurveyContributorsById]: Erro ao apagar contribuidor da pesquisa.", err)
	}

	if len(deletedContributor) == 0 {
		log.Println("[DeleteSurveyContributorsById]: Nenhum colaborador encontrado.")
		return errors.New("erro ao buscar jogador no banco de dados")
	}

	return nil
}


============================================================


ðŸ“„ Arquivo : survey_group_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/survey_group_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"errors"
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func GetAllGroupsBySurveyId(surveyId, surveyType string) ([]models.SurveyGroup, error) {

	supabase := db.GetSupabase()

	var surveyGroups []models.SurveyGroup

	_, err := supabase.From("survey_group").Select("*","", false).Eq("survey_id", surveyId).Eq("survey_type", surveyType).ExecuteTo(&surveyGroups)

	if err != nil {
		log.Println("[GetAllGroupsBySurveyId] Erro ao buscar grupo no banco de dados")
		return []models.SurveyGroup{}, err
	}

	return surveyGroups, nil

}

func CreateSurveyGroup(surveyId string, surveyData models.CreateSurveyGroup) (models.SurveyGroup, error) {
	supabase := db.GetSupabase()

	// Convertendo para map[string]interface{}
	insertData := map[string]interface{}{
		"survey_id":   surveyId,
		"survey_type": surveyData.SurveyType,
	}

	var createdGroup models.SurveyGroup

	_, err := supabase.
		From("survey_group").
		Insert(insertData,false,"","","").
		Single().
		ExecuteTo(&createdGroup)

	if err != nil {
		log.Println("[CreateSurveyGroup] Erro ao criar grupo no banco de dados:", err)
		return models.SurveyGroup{}, err
	}

	return createdGroup, nil
}

func DeleteSurveyGroup(id string) error {
    supabase := db.GetSupabase()

    // Executa o delete na tabela survey_group, filtrando pelo ID

	var res []models.SurveyGroup

    _, err := supabase.
        From("survey_group").
        Delete("","").
        Eq("id", id).
        ExecuteTo(res)

    if err != nil {
        log.Printf("[DeleteSurveyGroup] Erro ao deletar grupo: %v\n", err)
        return err
    }

	if len(res) == 0 {
		return errors.New("survey Id selecionado nÃ£o existe ou jÃ¡ deletado")
	}
	
	return nil
}

============================================================


ðŸ“„ Arquivo : survey_region_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/survey_region_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func CreateSurveyRegion(surveyId, surveyType string, surveyRegionData models.CreateSurveyRegion) (models.SurveyRegion, error) {
	supabase := db.GetSupabase()

	// Convertendo para map[string]interface{}
	insertData := map[string]interface{}{
		"name":        surveyRegionData.Name,
		"lat":         surveyRegionData.Lat,
		"location_title": surveyRegionData.LocationTitle,
		"long":        surveyRegionData.Long,
		"survey_id":   surveyId,
		"survey_type": surveyType,
	}

	var createdSurveyRegion models.SurveyRegion

	_, err := supabase.
		From("survey_regions").
		Insert(insertData, false, "", "", "").
		Single().
		ExecuteTo(&createdSurveyRegion)

	if err != nil {
		log.Println("[CreateSurveyRegion] Erro ao criar regiÃ£o de pesquisa no banco de dados:", err)
		return models.SurveyRegion{}, err
	}

	return createdSurveyRegion, nil

}

func GetAllSurveyRegionsBySurveyId(surveyId string) ([]models.SurveyRegion, error) {
	supabase := db.GetSupabase()

	var surveyRegions []models.SurveyRegion

	_, err := supabase.From("survey_regions").
		Select("*", "", false).
		Eq("survey_id", surveyId).
		ExecuteTo(&surveyRegions)

	if err != nil {
		log.Println("[GetAllSurveyRegionsBySurveyId] Erro ao buscar regiÃµes de pesquisa no banco de dados:", err)
		return []models.SurveyRegion{}, err
	}

	return surveyRegions, nil

}

func GetAllSurveysBySurveyType(surveyType string) ([]models.SurveyRegion, error) {
	supabase := db.GetSupabase()

	var surveyRegions []models.SurveyRegion

	_, err := supabase.From("survey_regions").
		Select("*", "", false).
		Eq("survey_type", surveyType).
		ExecuteTo(&surveyRegions)

	if err != nil {
		log.Println("[GetAllSurveysBySurveyType] Erro ao buscar regiÃµes de pesquisa no banco de dados:", err)
		return []models.SurveyRegion{}, err
	}

	return surveyRegions, nil

}

func GetSurveyRegionById(id string) (models.SurveyRegion, error) {
	supabase := db.GetSupabase()

	var surveyRegion models.SurveyRegion

	_, err := supabase.From("survey_regions").
		Select("*", "", false).
		Eq("id", id).
		Single().
		ExecuteTo(&surveyRegion)

	if err != nil {
		log.Println("[GetSurveyRegionById] Erro ao buscar regiÃ£o de pesquisa no banco de dados:", err)
		return models.SurveyRegion{}, err
	}

	return surveyRegion, nil

}

func UpdateSurveyRegion(id string, surveyRegionData models.UpdateSurveyRegion) (models.SurveyRegion, error) {
	supabase := db.GetSupabase()

	// Convertendo para map[string]interface{}
	updateData := map[string]interface{}{
		"name": surveyRegionData.Name,
		"lat":  surveyRegionData.Lat,
		"long": surveyRegionData.Long,
		"location_title": surveyRegionData.LocationTitle,
	}

	var updatedSurveyRegion models.SurveyRegion

	_, err := supabase.
		From("survey_regions").
		Update(updateData, "", "").
		Eq("id", id).
		Single().
		ExecuteTo(&updatedSurveyRegion)

	if err != nil {
		log.Println("[UpdateSurveyRegion] Erro ao atualizar regiÃ£o de pesquisa no banco de dados:", err)
		return models.SurveyRegion{}, err
	}

	return updatedSurveyRegion, nil

}

func DeleteSurveyRegion(id string) ([]models.SurveyRegion, error) {
	supabase := db.GetSupabase()

	var deletedRecords []models.SurveyRegion

	// Executa o delete na tabela survey_region, filtrando pelo ID
	_, err := supabase.
		From("survey_regions").
		Delete("", "").
		Eq("id", id).
		ExecuteTo(&deletedRecords)

	if err != nil {
		log.Println("[DeleteSurveyRegion] Erro ao deletar regiÃ£o de pesquisa:", err)
		return deletedRecords, err
	}

	return deletedRecords, nil
}


============================================================


ðŸ“„ Arquivo : survey_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/survey_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"log"
	"fmt"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

var surveyTypeMap = map[string]string{
	"FormulÃ¡rio": "form_surveys",
	"EstÃ¡tica":   "static_surveys",
	"DinÃ¢mica":   "dynamic_surveys",
}

func CreateSurvey(surveyType string, createSurveyData models.CreateSurvey) (models.Survey, error) {
	supabase := db.GetSupabase()

	// Criando um mapa para representar os dados da pesquisa
	newSurvey := map[string]interface{}{
		"title":          createSurveyData.Title,
		"description":    createSurveyData.Description,
		"lat":            createSurveyData.Lat,
		"long":           createSurveyData.Long,
		"location_title": createSurveyData.LocationTitle,
		"research_id":    createSurveyData.ResearchId,
	}

	var survey models.Survey

	tableName, exists := surveyTypeMap[surveyType]
	if !exists {
		err := fmt.Errorf("tipo de survey invÃ¡lido: %s", surveyType)
		log.Println("[CreateSurvey] Erro:", err)
		return models.Survey{}, err
	}
	
	// Inserindo no banco de dados
	_, err := supabase.From(tableName).
		Insert(newSurvey, false, "", "", "").
		Single().
		ExecuteTo(&survey)

	if err != nil {
		log.Println("[CreateSurvey] Erro ao criar pesquisa:", err)
		return models.Survey{}, err
	}

	return survey, nil
}

func GetAllSurveys(surveyType string) ([]models.Survey, error) {
	supabase := db.GetSupabase()

	var surveys []models.Survey

	tableName, exists := surveyTypeMap[surveyType]
	if !exists {
		err := fmt.Errorf("tipo de survey invÃ¡lido: %s", surveyType)
		log.Println("[CreateSurvey] Erro:", err)
		return []models.Survey{}, err
	}

	_, err := supabase.From(tableName).
		Select("*", "", false).
		ExecuteTo(&surveys)

	if err != nil {
		log.Println("[GetAllSurveys] Erro ao buscar pesquisas:", err)
		return nil, err
	}

	return surveys, nil
}

func GetSurveyById(id, researchId, surveyType string) (models.Survey, error) {
	supabase := db.GetSupabase()

	tableName, exists := surveyTypeMap[surveyType]
	if !exists {
		err := fmt.Errorf("tipo de survey invÃ¡lido: %s", surveyType)
		log.Println("[CreateSurvey] Erro:", err)
		return models.Survey{}, err
	}
	

	var survey models.Survey

	_, err := supabase.From(tableName).
		Select("*", "", false).
		Eq("id", id).
		Eq("research_id", researchId).
		Single().
		ExecuteTo(&survey)

	if err != nil {
		log.Println("[GetSurveyById] Erro ao buscar pesquisa:", err)
		return models.Survey{}, err
	}

	return survey, nil
}

func UpdateSurveyById(id, surveyType string, updateData models.UpdateSurvey) (models.Survey, error) {
	supabase := db.GetSupabase()

	tableName, exists := surveyTypeMap[surveyType]
	if !exists {
		err := fmt.Errorf("tipo de survey invÃ¡lido: %s", surveyType)
		log.Println("[CreateSurvey] Erro:", err)
		return models.Survey{}, err
	}

	// Criando um mapa com os dados atualizados
	updatedFields := map[string]interface{}{
		"title":          updateData.Title,
		"description":    updateData.Description,
		"lat":            updateData.Lat,
		"long":           updateData.Long,
		"location_title": updateData.LocationTitle,
	}

	var survey models.Survey

	_, err := supabase.From(tableName).
		Update(updatedFields, "", "").
		Eq("id", id).
		Single().
		ExecuteTo(&survey)

	if err != nil {
		log.Println("[UpdateSurveyById] Erro ao atualizar pesquisa:", err)
		return models.Survey{}, err
	}

	return survey, nil
}

func DeleteSurveyById(id, surveyType string) (models.Survey, error) {
	supabase := db.GetSupabase()

	tableName, exists := surveyTypeMap[surveyType]
	if !exists {
		err := fmt.Errorf("tipo de survey invÃ¡lido: %s", surveyType)
		log.Println("[CreateSurvey] Erro:", err)
		return models.Survey{}, err
	}


	var survey models.Survey

	_, _, err := supabase.From(tableName).
		Delete("","").
		Eq("id", id).
		Single().
		Execute()

	if err != nil {
		log.Println("[DeleteSurveyById] Erro ao deleatar pesquisa:", err)
		return models.Survey{}, err
	}

	return survey, nil
}

// Buscar pesquisas por research_id
func GetSurveysByResearchId(researchId, surveyType string) ([]models.Survey, error) {
	supabase := db.GetSupabase()

	tableName, exists := surveyTypeMap[surveyType]
	if !exists {
		err := fmt.Errorf("tipo de survey invÃ¡lido: %s", surveyType)
		log.Println("[CreateSurvey] Erro:", err)
		return []models.Survey{}, err
	}

	var surveys []models.Survey

	_, err := supabase.From(tableName).
		Select("*", "", false).
		Eq("research_id", researchId).
		ExecuteTo(&surveys)

	if err != nil {
		return nil, err
	}

	return surveys, nil
}


============================================================


ðŸ“„ Arquivo : survey_time_ranges_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/survey_time_ranges_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func CreateSurveyTimeRange(surveyId, surveyType string, surveyTimeData models.CreateSurveyTimeRange) (models.SurveyTimeRange, error) {
	supabase := db.GetSupabase()

	// Convertendo para map[string]interface{}
	insertData := map[string]interface{}{
		"start_time": surveyTimeData.StartTime,
		"end_time":   surveyTimeData.EndTime,
		"survey_id":  surveyId,
		"survey_type": surveyType,
	}

	var createdSurveyTimeRange models.SurveyTimeRange

	_, err := supabase.
		From("survey_time_ranges").
		Insert(insertData, false, "", "", "").
		Single().
		ExecuteTo(&createdSurveyTimeRange)

	if err != nil {
		log.Println("[CreateSurveyTimeRange] Erro ao criar intervalo de tempo de pesquisa no banco de dados:", err)
		return models.SurveyTimeRange{}, err
	}

	return createdSurveyTimeRange, nil
}

func GetAllSurveyRegionsBySurveyType(surveyType string) ([]models.SurveyTimeRange, error) {
	supabase := db.GetSupabase()

	var surveyTimeRanges []models.SurveyTimeRange

	_, err := supabase.From("survey_time_ranges").
		Select("*", "", false).
		Eq("survey_type", surveyType).
		ExecuteTo(&surveyTimeRanges)

	if err != nil {
		log.Println("[GetAllSurveyRegionsBySurveyType] Erro ao buscar regiÃµes de pesquisa no banco de dados:", err)
		return []models.SurveyTimeRange{}, err
	}

	return surveyTimeRanges, nil
}

func GetAllSurveyTimeRangeBySurveyId(surveyId string) ([]models.SurveyTimeRange, error) {
	supabase := db.GetSupabase()

	var surveyTimeRanges []models.SurveyTimeRange

	_, err := supabase.From("survey_time_ranges").
		Select("*", "", false).
		Eq("survey_id", surveyId).
		ExecuteTo(&surveyTimeRanges)

	if err != nil {
		log.Println("[GetSurveyTimeRangeBySurveyId] Erro ao buscar intervalos de tempo de pesquisa no banco de dados:", err)
		return []models.SurveyTimeRange{}, err
	}

	return surveyTimeRanges, nil
}

func GetSurveyTimeRangeById(id string) (models.SurveyTimeRange, error) {
	supabase := db.GetSupabase()

	var surveyTimeRange models.SurveyTimeRange

	_, err := supabase.From("survey_time_ranges").
		Select("*", "", false).
		Eq("id", id).
		Single().
		ExecuteTo(&surveyTimeRange)

	if err != nil {
		log.Println("[GetSurveyTimeRangeById] Erro ao buscar intervalo de tempo de pesquisa no banco de dados:", err)
		return models.SurveyTimeRange{}, err
	}

	return surveyTimeRange, nil
}

func UpdateSurveyTimeRange(id string, surveyTimeData models.UpdateSurveyTimeRange) (models.SurveyTimeRange, error) {
	supabase := db.GetSupabase()

	// Convertendo para map[string]interface{}
	updateData := map[string]interface{}{
		"start_time": surveyTimeData.StartTime,
		"end_time":   surveyTimeData.EndTime,
	}

	var updatedSurveyTimeRange models.SurveyTimeRange

	_, err := supabase.
		From("survey_time_ranges").
		Update(updateData, "", "").
		Eq("id", id).
		Single().
		ExecuteTo(&updatedSurveyTimeRange)

	if err != nil {
		log.Println("[UpdateSurveyTimeRange] Erro ao atualizar intervalo de tempo de pesquisa no banco de dados:", err)
		return models.SurveyTimeRange{}, err
	}

	return updatedSurveyTimeRange, nil
}

func DeleteSurveyTimeRange(id string) ([]models.SurveyTimeRange, error) {
	supabase := db.GetSupabase()

	var deletedSurveyTimeRange []models.SurveyTimeRange

	// Executa o delete na tabela survey_time_ranges, filtrando pelo ID
	_, err := supabase.
		From("survey_time_ranges").
		Delete("", "").
		Eq("id", id).
		ExecuteTo(&deletedSurveyTimeRange)

	if err != nil {
		log.Println("[DeleteSurveyTimeRange] Erro ao deletar intervalo de tempo de pesquisa no banco de dados:", err)
		return deletedSurveyTimeRange, err
	}

	return deletedSurveyTimeRange, nil
}

============================================================


ðŸ“„ Arquivo : token_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/token_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
	"time"
)

// GetToken busca um token especÃ­fico no banco de dados
func GetToken(token string) (*models.Token, error) {
	supabase := db.GetSupabase()

	var tokens []models.Token
	_, err := supabase.From("tokens").
		Select("*", "", false).
		Eq("token", token).
		ExecuteTo(&tokens)

	if err != nil {
		log.Println("[GetToken] Erro:", err)
		return nil, err
	}

	if len(tokens) > 0 {
		return &tokens[0], nil
	}
	return nil, nil
}

// GetTokenByUserID busca um token pelo user_id e tipo
func GetTokenByUserID(userID string, tokenType string) (*models.Token, error) {
	supabase := db.GetSupabase()

	var tokens []models.Token
	_, err := supabase.From("tokens").
		Select("*", "", false).
		Eq("user_id", userID).
		Eq("token_type", tokenType).
		ExecuteTo(&tokens)

	if err != nil {
		log.Println("[GetTokenByUserID] Erro:", err)
		return nil, err
	}

	if len(tokens) > 0 {
		return &tokens[0], nil
	}
	return nil, nil
}

// InsertToken insere um novo token no banco
func InsertToken(userID string, token string, tokenType string, expiresAt time.Time) (*models.Token, error) {
	supabase := db.GetSupabase()

	newToken := models.Token{
		User_id:    userID,
		Token:      token,
		TokenType:  tokenType,
		Expires_at: expiresAt.Format(time.RFC3339), // Garante o formato correto
		Created_at: time.Now().Format(time.RFC3339),
		Active:     true,
	}

	var insertedTokens []models.Token
	_, err := supabase.From("tokens").
		Insert(map[string]interface{}{
			"user_id":    newToken.User_id,
			"token":      newToken.Token,
			"token_type": newToken.TokenType,
			"expires_at": newToken.Expires_at, // Converte time.Time para string no formato ISO 8601
			"created_at": newToken.Created_at,
			"active":     newToken.Active,
		}, false, "", "", "").
		ExecuteTo(&insertedTokens)

	if err != nil {
		log.Println("[InsertToken] Erro:", err)
		return nil, err
	}

	if len(insertedTokens) > 0 {
		return &insertedTokens[0], nil
	}
	return nil, nil
}

// RevokeToken desativa um token especÃ­fico
func RevokeToken(token string) error {
	supabase := db.GetSupabase()

	_ ,_, err := supabase.From("tokens").
		Update(map[string]interface{}{"active": false}, "", "").
		Eq("token", token).
		Execute()

	if err != nil {
		log.Println("[RevokeToken] Erro:", err)
		return err
	}
	return nil
}

// RevokeAllTokensByUserID desativa todos os tokens de um usuÃ¡rio por tipo
func RevokeAllTokensByUserID(userID string, tokenType string) error {
	supabase := db.GetSupabase()

	_, _, err := supabase.From("tokens").
		Update(map[string]interface{}{"active": false}, "", "").
		Eq("user_id", userID).
		Eq("token_type", tokenType).
		Execute()

	if err != nil {
		log.Println("[RevokeAllTokensByUserID] Erro:", err)
		return err
	}
	return nil
}


============================================================


ðŸ“„ Arquivo : user_repository.go
ðŸ“‚ Pasta   : repositories
ðŸ§­ Caminho : repositories/user_repository.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package repository

import (
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/models"
)

func GetUserById(id string) (models.User, error) {
	supabase := db.GetSupabase()

	var user models.User

	_, err := supabase.From("users").
		Select("*", "", false).
		Eq("id", id).
		Single().
		ExecuteTo(&user) // Decodifica para a struct User

	if err != nil {
		log.Println("Erro ao buscar usuÃ¡rio:", err)
		return models.User{}, err
	}

	// Converte timestamps
	user.ConvertTimestamps()

	return user, nil
}

func GetUserByEmail(email string) (models.User, error) {
	supabase := db.GetSupabase()

	var user models.User

	_, err := supabase.From("users").
		Select("*", "", false).
		Eq("email", email).
		Single().
		ExecuteTo(&user) // Decodifica para a struct User

	if err != nil {
		log.Println("Erro ao buscar usuÃ¡rio:", err)
		return models.User{}, err
	}

	// Converte timestamps
	user.ConvertTimestamps()

	return user, nil
}

func GetAllUsers() ([]models.SanitizedUser, error){
	supabase := db.GetSupabase()

	var users []models.User

	_, err := supabase.From("users").
	Select("*", "", false).
	ExecuteTo(&users) // Decodifica para a struct User

	if err != nil {
		log.Println("Erro ao buscar usuÃ¡rios:", err) 
		return nil, err
	}

	var sanitizedUsers []models.SanitizedUser
	for _, user := range users {
		user.ConvertTimestamps()
		sanitizedUsers = append(sanitizedUsers, models.SanitizeUser(user))
	}

	return sanitizedUsers, nil
}

func DeleteUserById(id string) error {
	supabase := db.GetSupabase()

	_, _, err := supabase.From("users").
		Delete("", "").
		Eq("id", id). // Filtra pelo ID do usuÃ¡rio
		Execute()


	if err != nil {
		log.Println("Erro ao deletar usuÃ¡rio:", err)
		return err
	}

	return nil
}

func UpdateUserById(id string, updatedData map[string]interface{}) (models.User, error) {
	supabase := db.GetSupabase()

	var updatedUser models.User

	_, err := supabase.From("users").
		Update(updatedData, "", ""). 
		Eq("id", id).
		Single().
		ExecuteTo(&updatedUser)

	if err != nil {
		log.Println("Erro ao atualizar usuÃ¡rio:", err)
		return models.User{}, err
	}

	return updatedUser, nil
}

func InsertUser(createUserData models.InsertUser) (*models.User, error) {
	supabase := db.GetSupabase()

	var user models.User

	role := string([]rune(createUserData.Role)[:])

	// InserÃ§Ã£o no banco de dados
	_, err := supabase.From("users").Insert(map[string]interface{}{
		"name":     createUserData.Name,
		"email":    createUserData.Email,
		"password": createUserData.Password,
		"role":     role,
		"status":   createUserData.Status,
	},false,"","","").Single().ExecuteTo(&user)

	if err != nil {
		return nil, err
	}

	return &user, nil
}


func UpdateUserPassword(userID string, password string) error {
	supabase := db.GetSupabase()

	_, _, err := supabase.From("users").
		Update(map[string]interface{}{"password": password}, "", "").
		Eq("id", userID).
		Execute()

	if err != nil {
		return err
	}

	return nil
}

============================================================


ðŸ“„ Arquivo : router.go
ðŸ“‚ Pasta   : routes
ðŸ§­ Caminho : routes/router.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package routes

import (
	"placemaking-backend-go/controllers"
	"placemaking-backend-go/middleware"

	"github.com/gin-gonic/gin"
)

func SetupRouter() *gin.Engine {
	router := gin.Default()

	// Lista de rotas pÃºblicas dentro de /api/v1
	publicRoutes := map[string]bool{
		"POST /api/v1/auth/login":           true,
		"POST /api/v1/auth/register":        true,
		"POST /api/v1/auth/forgot_password": true,
		"POST /api/v1/auth/validate_code":   true,
	}

	// Todas as rotas dentro de /api/v1 passam pelo middleware
	api := router.Group("/api/v1")
	api.Use(middleware.JWTAuthMiddleware(publicRoutes))
	{
		// Grupo de autenticaÃ§Ã£o
		auth := api.Group("/auth")
		{
			auth.POST("/login", controllers.Login)
			auth.POST("/register", controllers.Register)
			auth.POST("/forgot_password", controllers.ForgotPassword)
			auth.POST("/validate_code", controllers.ValidateCode)
			auth.POST("/logout", controllers.Logout)
			auth.PUT("/reset_password", controllers.ResetPassword)
		}

		// Grupo de usuÃ¡rios
		users := api.Group("/users")
		{
			users.GET("/:id", controllers.GetUserById)
			users.GET("", controllers.GetAllUsers)
			users.PUT("/:id", controllers.UpdateUserById)
			users.DELETE("/:id", controllers.DeleteUserById)
		}

		// Grupo de pesquisas
		researches := api.Group("/research")
		{
			researches.POST("", controllers.CreateResearch)
			researches.GET("", controllers.GetAllResearches)
			researches.GET("/:researchId", controllers.GetResearchById)
			researches.PUT("/:researchId", controllers.UpdateResearch)
			researches.DELETE("/:researchId", controllers.DeleteResearch)

			// Grupo de colaboradores dentro de uma pesquisa (evitando conflito com :id)
			contributors := researches.Group("/:researchId/contributors")
			{
				contributors.POST("/:userId", controllers.CreateContributor)
				contributors.GET("", controllers.GetAllContributorsByResearchId)
				contributors.GET("/:userId", controllers.GetContributorByResearchAndUserId)
				contributors.DELETE("/:userId", controllers.DeleteContributorByResearchAndUserId)
			}

			// Grupo de surveys dentro de uma pesquisa
			surveys := researches.Group("/:researchId/survey")
			{
				surveys.GET("", controllers.GetSurveysByResearchId)
				surveys.GET("/:surveyId", controllers.GetSurveyById) //survey**
				surveys.DELETE("/:surveyId", controllers.DeleteSurveyById)
			}
		}

		//Rotas para Contributors
		contributor := api.Group("/contributors")
		{
			contributor.GET("/:contributorId", controllers.GetContributorById)
			contributor.PUT("/:contributorId", controllers.UpdateContributorById)
			contributor.DELETE("/:contributorId", controllers.DeleteContributorById)
			contributor.GET("/:contributorId/answers", controllers.GetSurveyAnswersByContributorId)
		}

		//Rotas para surveys
		survey := api.Group("/survey")
		{
			survey.POST("", controllers.CreateSurvey)
			survey.PUT("/:surveyId", controllers.UpdateSurveyById)

			fields := survey.Group("/:surveyId/fields")
			{
				fields.POST("", controllers.CreateField)
				fields.GET("", controllers.GetAllFieldsBySurveyId)
				fields.PUT("/:fieldId", controllers.UpdateField)
				fields.DELETE("/:fieldId", controllers.DeleteField)
			}

			survey_contributors := survey.Group("/:surveyId/contributors")
			{
				survey_contributors.GET("", controllers.GetSurveyContributorsBySurveyId)
				survey_contributors.POST("", controllers.CreateSurveyContributor)
				survey_contributors.DELETE("/:contributorId", controllers.DeleteSurveyContributor)
			}

			survey_answers := survey.Group("/:surveyId/answers")
			{
				survey_answers.POST("", controllers.CreateSurveyAnswer)
				survey_answers.GET("", controllers.GetSurveyAnswersBySurveyId)
				survey_answers.DELETE("/:answerId", controllers.DeleteSurveyAnswerById)
				survey_answers.GET("/:answerId", controllers.GetSurveyAnswerById)
				survey_answers.PUT("/:answerId", controllers.UpdateSurveyAnswerById)
			}

			survey_group := survey.Group("/:surveyId/group")
			{
				survey_group.POST("", controllers.CreateSurveyGroup)
				survey_group.GET("", controllers.GetSurveyGroups)
				survey_group.DELETE("/:groupId", controllers.DeleteSurveyGroup)
			}

			survey_region := survey.Group("/:surveyId/region")
			{
				survey_region.POST("", controllers.CreateSurveyRegion)
				survey_region.GET("", controllers.GetAllSurveyRegionsBySurveyId)
				survey_region.DELETE("/:regionId", controllers.DeleteSurveyRegion)
				survey_region.GET("/:regionId", controllers.GetSurveyRegionById)
				survey_region.PUT("/:regionId", controllers.UpdateSurveyRegionById)

			}

			survey_time_range := survey.Group("/:surveyId/time")
			{
				survey_time_range.POST("", controllers.CreateSurveyTimeRange)
				survey_time_range.GET("", controllers.GetAllSurveyTimeRangeBySurveyId)
				survey_time_range.DELETE("/:timeRangeId", controllers.DeleteSurveyTimeRange)
				survey_time_range.GET("/:timeRangeId", controllers.GetSurveyTimeRangeById)
				survey_time_range.PUT("/:timeRangeId", controllers.UpdateSurveyTimeRangeById)
			}
		}
		//Grupo de Field options
		field_option := api.Group("/fields/:fieldId/options")
		{
			field_option.GET("", controllers.GetAllFieldOptionsByFieldId)
			field_option.POST("", controllers.CreateFieldOption)
			field_option.DELETE("/:optionId", controllers.DeleteFieldOptionById)
		}

		// Grupo de tipos de input
		api.GET("/input_types", controllers.GetInputTypes)
	}

	return router
}


============================================================


ðŸ“„ Arquivo : server.go
ðŸ“‚ Pasta   : server
ðŸ§­ Caminho : server/server.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package main

import (
	"log"
	"placemaking-backend-go/db"
	"placemaking-backend-go/routes"
)

func main() {
	// Inicializa Supabase
	db.InitSupabase()

	// Configura o servidor
	router := routes.SetupRouter() // Agora a funÃ§Ã£o SetupRouter Ã© reconhecida

	log.Println("Server running on http://localhost:8000...")
	if err := router.Run(":8000"); err != nil {
		log.Fatal("Error starting server:", err)
	}
}


============================================================


ðŸ“„ Arquivo : auth_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/auth_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"bytes"
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"placemaking-backend-go/templates"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
)

func RegisterUser(createUserData models.CreateUser) (*models.SanitizedUser, string, error) {
	// Verifica se os e-mails conferem
	if createUserData.Email != createUserData.ConfirmEmail {
		log.Println("error: Emails nÃ£o conferem")
		return nil, "", fmt.Errorf("emails nÃ£o conferem")
	}

	// Gera senha temporÃ¡ria e a criptografa
	temporary_password := GenerateUserPassword()

	hashed_password, err := GenerateHashedPassword(temporary_password)
	if err != nil {
		log.Println("erro ao criptografar a senha:", err)
		return nil, "", err
	}

	// Preenche os dados para inserÃ§Ã£o
	insertUserData := models.InsertUser{
		Name:     createUserData.Name,
		Email:    createUserData.Email,
		Password: hashed_password,
		Role:     createUserData.Role,
		Status:   "active",
	}

	// Insere usuÃ¡rio no banco de dados
	new_user, err := repository.InsertUser(insertUserData)
	if err != nil {
		log.Println("error: Erro ao cadastrar o usuÃ¡rio:", err)
		return nil, "", err
	}

	// Desreferencia o ponteiro para passar um valor, nÃ£o um ponteiro
	sanitizedUser := models.SanitizeUser(*new_user)
	return &sanitizedUser, temporary_password, nil
}

// LoginUser autentica um usuÃ¡rio e retorna um token JWT se for bem-sucedido.
func LoginUser(email string, password string) (map[string]interface{}, error) {
	// Busca o usuÃ¡rio pelo email
	existingUser, err := repository.GetUserByEmail(email)
	if err != nil {
		return map[string]interface{}{"error": "UsuÃ¡rio nÃ£o encontrado"}, err
	}

	// Verifica a senha
	if !CheckPassword(password, existingUser.Password) {
		return map[string]interface{}{"error": "Senha invÃ¡lida"}, err
	}

	// Gera um token JWT para o usuÃ¡rio autenticado
	token, err := GenerateUserToken(existingUser, "Bearer")
	if err != nil {
		log.Println("Erro ao gerar token:", err)
		return map[string]interface{}{"error": "Erro ao gerar token"}, err
	}

	// Retorna os dados sanitizados do usuÃ¡rio e o token
	return map[string]interface{}{
		"token": models.SanitizeToken(*token),
		"user":  models.SanitizeUser(existingUser),
	}, nil
}

func LogoutUser(token string) {
	err := RevokeToken(token)
	if err != nil {
		log.Println("error: erro ao fazer logout:", err)
		return
	}
}

// SendUserData envia um e-mail de boas-vindas para o usuÃ¡rio
func SendUserData(data map[string]interface{}) error {
	// Obtendo os dados do usuÃ¡rio
	userData, ok := data["user"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("erro: estrutura de usuÃ¡rio invÃ¡lida")
	}

	email, emailOk := userData["email"].(string)
	name, nameOk := userData["name"].(string)
	tempPassword, passOk := data["temporary_password"].(string)

	// Valida se os dados essenciais estÃ£o presentes
	if !emailOk || !nameOk || !passOk {
		return fmt.Errorf("erro: dados do usuÃ¡rio incompletos")
	}

	// Caminho do arquivo de template HTML
	templateFilePath := "assets/templates/welcome.html"

	// Lendo o arquivo do template
	fileContent, err := templates.FS.ReadFile(templateFilePath)
	if err != nil {
		fmt.Println("Erro ao ler template:", err)
		return fmt.Errorf("erro ao ler o template de e-mail: %w", err)
	}

	// Criando o template e registrando funÃ§Ãµes extras
	tmpl, err := template.New("email").Funcs(template.FuncMap{}).Parse(string(fileContent))
	if err != nil {
		return fmt.Errorf("erro ao processar template: %w", err)
	}

	// Criando o conteÃºdo do e-mail
	renderedEmailContent := new(bytes.Buffer)
	emailData := models.EmailData{
		Name:         name,
		TempPassword: tempPassword,
	}

	// Executando o template com os dados
	err = tmpl.Execute(renderedEmailContent, emailData)
	if err != nil {
		return fmt.Errorf("erro ao renderizar o template: %w", err)
	}

	// Enviar o e-mail
	err = SendEmail(email, renderedEmailContent.String(), "Cadastro realizado com sucesso!")
	if err != nil {
		return fmt.Errorf("erro ao enviar e-mail: %w", err)
	}

	return nil
}

func SendForgotEmailPasswordData(data map[string]interface{}) error {
	fmt.Println("Iniciando envio de e-mail de recuperaÃ§Ã£o...")

	userStruct, ok := data["user"].(models.User)
	if !ok {
		return fmt.Errorf("erro: estrutura de usuÃ¡rio invÃ¡lida")
	}

	// Serializa a struct para JSON
	userJSON, err := json.Marshal(userStruct)
	if err != nil {
		return fmt.Errorf("erro ao serializar usuÃ¡rio: %w", err)
	}

	// Converte o JSON para um map[string]interface{}
	var userData map[string]interface{}
	err = json.Unmarshal(userJSON, &userData)
	if err != nil {
		return fmt.Errorf("erro ao desserializar usuÃ¡rio: %w", err)
	}
	
	email, emailOk := userData["email"].(string)
	name, nameOk := userData["name"].(string)
	token, tokenOk := data["token"].(string)

	// Valida se os dados essenciais estÃ£o presentes
	if !emailOk || !nameOk || !tokenOk {
		fmt.Println("Erro: dados do usuÃ¡rio incompletos")
		return fmt.Errorf("erro: dados do usuÃ¡rio incompletos")
	}

	fmt.Printf("Enviando e-mail para %s (%s), token: %s\n", name, email, token)

	// Caminho do arquivo de template HTML
	templateFilePath := "assets/templates/recovery-password.html"

	// Lendo o arquivo do template
	fileContent, err := templates.FS.ReadFile(templateFilePath)
	if err != nil {
		fmt.Println("Erro ao ler template:", err)
		return fmt.Errorf("erro ao ler o template de e-mail: %w", err)
	}

	// Criando o template e registrando funÃ§Ãµes extras
	tmpl, err := template.New("email").Funcs(template.FuncMap{}).Parse(string(fileContent))
	if err != nil {
		fmt.Println("Erro ao processar template:", err)
		return fmt.Errorf("erro ao processar template: %w", err)
	}

	// Criando o conteÃºdo do e-mail
	renderedEmailContent := new(bytes.Buffer)
	emailData := models.RecoveryEmailData{
		Name:  name,
		Token: token,
	}

	// Executando o template com os dados
	err = tmpl.Execute(renderedEmailContent, emailData)
	if err != nil {
		fmt.Println("Erro ao renderizar template:", err)
		return fmt.Errorf("erro ao renderizar o template: %w", err)
	}

	fmt.Println("ConteÃºdo do e-mail gerado com sucesso!")

	// Enviar o e-mail
	err = SendEmail(email, renderedEmailContent.String(), "RecuperaÃ§Ã£o de Senha")
	if err != nil {
		fmt.Println("Erro ao enviar e-mail:", err)
		return fmt.Errorf("erro ao enviar e-mail: %w", err)
	}

	fmt.Println("E-mail enviado com sucesso!")
	return nil
}

func ForgotPasswordService(email string) (map[string]interface{}, error) {

	user, err := repository.GetUserByEmail(email)

	if err != nil {
		return map[string]interface{}{"error": "UsuÃ¡rio nÃ£o encontrado"}, nil
	}

	token, err := GenerateUserToken(user, "RecoverPassword")

	if err != nil {
		return map[string]interface{}{"error": "Erro ao gerar token"}, nil
	}

	return map[string]interface{}{"error": nil, "token": token.Token, "user": user}, nil
}

func ValidateCodeService(token string) (map[string]interface{}, error) {
	tokenToValidate, err := repository.GetToken(token)

	if err != nil {
		return map[string]interface{}{"error": "CÃ³digo invÃ¡lido ou nÃ£o encontrado."}, err
	}

	if tokenToValidate.Token != token {
		return map[string]interface{}{"error": "CÃ³digo invÃ¡lido."}, nil
	}

	user, err := repository.GetUserById(tokenToValidate.User_id)

	if err != nil {
		return map[string]interface{}{"error": "Erro ao buscar usuÃ¡rio no banco de dados."}, err
	}

	accessToken, err := GenerateUserToken(user, "Bearer")

	if err != nil {
		return map[string]interface{}{"error": "Erro ao gerar token de usuÃ¡rio"}, err
	}

	return map[string]interface{}{
		"error": nil, 
		"access_token": models.SanitizeToken(*accessToken), 
		"validated_token": tokenToValidate.Token, 
		"user": user}, nil
}

func ResetPasswordService(newPassword, confirmPassword, userID string) (map[string]interface{}, error) {

	if newPassword != confirmPassword {
		return map[string]interface{}{"error": "Senhas nÃ£o conferem"}, nil
	}

	hashedPassword, err := GenerateHashedPassword(newPassword)
	if err != nil {
		return map[string]interface{}{"error": "Erro ao criptografar a nova senha."}, err
	}

	err = repository.UpdateUserPassword(userID, hashedPassword)
	if err != nil {
		return map[string]interface{}{"error": "Erro ao atualizar senha no banco."}, err
	}

	return map[string]interface{}{"message": "Senha redefinida com sucesso!"}, nil
}


============================================================


ðŸ“„ Arquivo : contributors_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/contributors_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"log"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
)

func CreateContributor(researchId, userId string, contributorData models.CreateContributor) (models.Contributor, error) {
	contributor, err := repository.CreateContributor(researchId, userId, contributorData)
	if err != nil {
		log.Println("[Service] Erro ao criar colaborador:", err)
		return models.Contributor{}, err
	}
	return contributor, nil
}

func GetContributorById(id string) (models.Contributor, error) {
	contributor, err := repository.GetContributorById(id)
	if err != nil {
		log.Println("[Service] Erro ao buscar colaborador por ID:", err)
		return models.Contributor{}, err
	}
	return contributor, nil
}

func UpdateContributorById(id string, updateData models.UpdateContributor) (models.Contributor, error) {
	contributor, err := repository.UpdateContributorById(id, updateData)
	if err != nil {
		log.Println("[Service] Erro ao atualizar colaborador:", err)
		return models.Contributor{}, err
	}
	return contributor, nil
}

func DeleteContributorById(id string) error {
	err := repository.DeleteContributorById(id)
	if err != nil {
		log.Println("[Service] Erro ao deletar colaborador:", err)
		return err
	}
	return nil
}

func GetAllContributorsByResearchId(researchId string) ([]models.ViewContributor, error) {
	contributors, err := repository.GetAllContributorsByResearchId(researchId)
	if err != nil {
		log.Println("[Service] Erro ao buscar colaboradores por ID da pesquisa:", err)
		return nil, err
	}

	var viewContributors []models.ViewContributor
    for _, contributor := range contributors {
        user, err := repository.GetUserById(contributor.UserId) // Supondo que essa funÃ§Ã£o exista
        if err != nil {
            log.Println("[Service] Erro ao buscar usuÃ¡rio do colaborador:", err)
            return nil, err
        }

        viewContributor := models.ViewContributor{
            ID:          contributor.ID,
            ResearchId:  contributor.ResearchId,
            UserId:      contributor.UserId,
            Instruction: contributor.Instruction,
            User:        models.SanitizeUser(user), // Atribui o usuÃ¡rio Ã  estrutura
        }
        viewContributors = append(viewContributors, viewContributor)
    }

	return viewContributors, nil
}

func GetContributorByResearchAndUserId(researchId, userId string) (models.Contributor, error) {
	contributor, err := repository.GetContributorByResearchAndUserId(researchId, userId)
	if err != nil {
		log.Println("[Service] Erro ao buscar colaborador por pesquisa e usuÃ¡rio:", err)
		return models.Contributor{}, err
	}
	return contributor, nil
}

func DeleteContributorByResearchAndUserId(researchId, userId string) error {
	err := repository.DeleteContributorByResearchAndUserId(researchId, userId)
	if err != nil {
		log.Println("[Service] Erro ao deletar colaborador por pesquisa e usuÃ¡rio:", err)
		return err
	}
	return nil
}


============================================================


ðŸ“„ Arquivo : email_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/email_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"crypto/tls"
	"fmt"
	"net/smtp"
	"github.com/jordan-wright/email"
	"placemaking-backend-go/config"
)

// SendEmail envia um e-mail para o usuÃ¡rio.
func SendEmail(to string, content string, subject string) error {
	from := config.LoadSettings().GmailUser
	password := config.LoadSettings().GmailPass
	smtpServer := "smtp.gmail.com"
	smtpPort := "465"

	e := email.NewEmail()
	e.From = from
	e.To = []string{to}
	e.Subject = subject
	e.HTML = []byte(content)

	// ConfiguraÃ§Ã£o para conexÃ£o segura com TLS
	smtpAuth := smtp.PlainAuth("", from, password, smtpServer)
	tlsConfig := &tls.Config{
		InsecureSkipVerify: true,
		ServerName:         smtpServer,
	}

	// Criando conexÃ£o SMTP segura
	smtpAddr := fmt.Sprintf("%s:%s", smtpServer, smtpPort)
	conn, err := tls.Dial("tcp", smtpAddr, tlsConfig)
	if err != nil {
		return fmt.Errorf("erro ao conectar ao servidor SMTP: %w", err)
	}
	defer conn.Close()

	client, err := smtp.NewClient(conn, smtpServer)
	if err != nil {
		return fmt.Errorf("erro ao criar cliente SMTP: %w", err)
	}
	defer client.Close()

	// Autenticando no servidor SMTP
	if err := client.Auth(smtpAuth); err != nil {
		return fmt.Errorf("erro ao autenticar no SMTP: %w", err)
	}

	// Enviando e-mail
	if err := e.SendWithTLS(smtpAddr, smtpAuth, tlsConfig); err != nil {
		return fmt.Errorf("erro ao enviar e-mail: %w", err)
	}

	fmt.Printf("E-mail enviado para %s com sucesso!\n", to)
	return nil
}

============================================================


ðŸ“„ Arquivo : field_option_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/field_option_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"placemaking-backend-go/models"
	"placemaking-backend-go/repositories"
)

// CreateFieldOptionService cria uma nova opÃ§Ã£o para um campo
func CreateFieldOptionService(fieldId string, createFieldOptionData models.CreateFieldOption) (models.FieldOption, error) {
	return repository.CreateFieldOption(fieldId, createFieldOptionData)
}

// GetAllFieldOptionsByFieldIdService retorna todas as opÃ§Ãµes de um campo
func GetAllFieldOptionsByFieldIdService(fieldId string) ([]models.FieldOption, error) {
	return repository.GetAllFieldOptionsByFieldId(fieldId)
}

// DeleteFieldOptionByIdService deleta uma opÃ§Ã£o de campo por ID
func DeleteFieldOptionByIdService(id, fieldId string) error {
	return repository.DeleteFieldOptionById(id, fieldId)
}


============================================================


ðŸ“„ Arquivo : fields_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/fields_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"placemaking-backend-go/models"
	"placemaking-backend-go/repositories"
)

// CreateFieldService cria um novo campo para um survey especÃ­fico
func CreateFieldService(surveyId, surveyType string, createFieldData models.CreateField) (models.Field, error) {
	return repository.CreateField(surveyId, surveyType, createFieldData)
}

// GetAllFieldsBySurveyIdService retorna todos os campos de um survey especÃ­fico
func GetAllFieldsBySurveyIdService(surveyId, surveyType string) ([]models.Field, error) {
	return repository.GetAllFieldsBySurveyId(surveyId, surveyType)
}

// DeleteFieldBySurveyIdService deleta um campo especÃ­fico de um survey
func DeleteFieldBySurveyIdService(id, surveyId, surveyType string) error {
	return repository.DeleteFieldBySurveyId(id, surveyId, surveyType)
}

// UpdateFieldService atualiza um campo especÃ­fico de um survey
func UpdateFieldService(id, surveyId, surveyType string, updateFieldData models.CreateField) (models.Field, error) {
	return repository.UpdateField(id, surveyId, surveyType, updateFieldData)
}


============================================================


ðŸ“„ Arquivo : input_type_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/input_type_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
    "placemaking-backend-go/models"
    repository "placemaking-backend-go/repositories"
)

func FetchInputTypes() ([]models.InputType, error) {
    return repository.GetAllInputTypes()
}


============================================================


ðŸ“„ Arquivo : research_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/research_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"log"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
)

func FetchCreateResearch(createResearchData models.CreateResearch) (models.Research, error) {
	research, err := repository.CreateResearch(createResearchData)

	if err != nil {
		log.Println("[FetchCreateResearch] Erro ao criar pesquisa:", err)
		return models.Research{}, err
	}

	return research, nil
}

func FetchAllResearches() ([]models.ViewResearch, error) {

	researches, err := repository.GetAllResearches()
	if err != nil {
		log.Println("[Service] Erro ao buscar pesquisas:", err)
		return nil, err
	}

	var viewResearches []models.ViewResearch
	for _, research := range researches {
		user, err := repository.GetUserById(research.CreatedBy)
		if err != nil {
			log.Println("[Service] Erro ao buscar usuÃ¡rio da pesquisa:", err)
			return nil, err
		}

		viewResearch := models.ViewResearch{
			Id:            research.Id,
			Title:         research.Title,
			Description:   research.Description,
			ReleaseDate:   research.ReleaseDate,
			CreatedBy:     models.SanitizeUser(user),
			Lat:           research.Lat,
			Long:          research.Long,
			LocationTitle: research.LocationTitle,
			EndDate:       research.EndDate,
		}

		viewResearches = append(viewResearches, viewResearch)
	}

	return viewResearches, nil
}

func FetchResearchById(id string) (models.ViewResearch, error){
	
	research, err := repository.GetResearchById(id)
	if err != nil {
		log.Println("[Service] Erro ao buscar pesquisa por ID:", err)
		return models.ViewResearch{}, err
	}

	user, err := repository.GetUserById(research.CreatedBy)
	if err != nil {
		log.Println("[Service] Erro ao buscar usuÃ¡rio da pesquisa:", err)
		return models.ViewResearch{}, err
	}

	viewResearch := models.ViewResearch{
		Id:            research.Id,
		Title:         research.Title,
		Description:   research.Description,
		ReleaseDate:   research.ReleaseDate,
		CreatedBy:     models.SanitizeUser(user),
		Lat:           research.Lat,
		Long:          research.Long,
		LocationTitle: research.LocationTitle,
		EndDate:       research.EndDate,
	}

	return viewResearch, nil
}

func FetchUpdateResearch(id string, updateResearchData models.UpdateResearch) (models.Research, error) {
	research, err := repository.UpdateResearchById(id, updateResearchData)
	if err != nil {
		log.Println("[FetchUpdateResearch] Erro ao atualizar pesquisa:", err)
		return models.Research{}, err
	}
	return research, nil
}

func FetchDeleteResearch(id string) ([]models.Research, error) {
	deletedResearch, err := repository.DeleteResearchById(id)
	if err != nil {
		log.Println("[FetchDeleteResearch] Erro ao deletar pesquisa:", err)
		return deletedResearch, err
	}
	return deletedResearch, nil
}


============================================================


ðŸ“„ Arquivo : survey_answer_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/survey_answer_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"log"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
)

// CreateSurveyAnswer cria uma nova resposta de pesquisa no banco de dados
func CreateSurveyAnswer(surveyId, surveyType, contributorId string, data models.CreateSurveyAnswer) (models.SurveyAnswer, error) {

	answer, err := repository.CreateSurveyAnswer(surveyId, surveyType, contributorId, data)
	if err != nil {
		log.Println("[CreateSurveyAnswer] Erro ao criar resposta de pesquisa no banco de dados:", err)
		return models.SurveyAnswer{}, err
	}
	return answer, nil
}

func GetSurveyAnswersBySurveyId(surveyId string) ([]models.SurveyAnswer, error) {
	answers, err := repository.GetAllSurveyAnswersBySurveyId(surveyId)
	if err != nil {
		log.Println("[GetSurveyAnswersBySurveyId] Erro ao buscar respostas de pesquisa no banco de dados:", err)
		return nil, err
	}
	return answers, nil
}

func GetSurveyAnswersByContributorId(contributorId string) ([]models.SurveyAnswer, error) {
	answers, err := repository.GetAllAnswersByContributorId(contributorId)
	if err != nil {
		log.Println("[GetSurveyAnswersByContributorId] Erro ao buscar respostas de pesquisa no banco de dados:", err)
		return nil, err
	}
	return answers, nil
}

func GetSurveyAnswerById(id string) (models.SurveyAnswer, error) {
	answer, err := repository.GetSurveyAnswerById(id)
	if err != nil {
		log.Println("[GetSurveyAnswerById] Erro ao buscar resposta de pesquisa no banco de dados:", err)
		return models.SurveyAnswer{}, err
	}
	return answer, nil
}

func UpdateSurveyAnswerById(id string, data models.UpdateSurveyAnswer) (models.SurveyAnswer, error) {
	answers, err := repository.UpdateSurveyAnswerById(id, data)
	if err != nil {
		log.Println("[UpdateSurveyAnswerById] Erro ao atualizar resposta de pesquisa no banco de dados:", err)
		return models.SurveyAnswer{}, err
	}
	return answers, nil
}

func DeleteSurveyAnswerById(id string) ([]models.SurveyAnswer, error) {
	answers, err := repository.DeleteSurveyAnswerById(id)
	if err != nil {
		log.Println("[DeleteSurveyAnswerById] Erro ao deletar resposta de pesquisa no banco de dados:", err)
		return nil, err
	}
	return answers, nil
}

============================================================


ðŸ“„ Arquivo : survey_contributors_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/survey_contributors_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"placemaking-backend-go/models"
	"placemaking-backend-go/repositories"
)

func CreateSurveyContributorService(id string, data models.CreateSurveyContributors) (models.SurveyContributors, error) {
	return repository.CreateSurveyContributors(id, data)
}

func GetSurveyContributorsBySurveyIdService(surveyId string) ([]models.SurveyContributors, error) {
	return repository.GetSurveyContributorsBySurveyId(surveyId)
}

func DeleteSurveyContributorsByIdService(id, surveyId string) error {
	return repository.DeleteSurveyContributorsById(id, surveyId)
}


============================================================


ðŸ“„ Arquivo : survey_group_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/survey_group_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"errors"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
)

// GetSurveyGroups retorna todos os grupos de uma pesquisa especÃ­fica
func GetSurveyGroups(surveyId, surveyType string) ([]models.SurveyGroup, error) {
	groups, err := repository.GetAllGroupsBySurveyId(surveyId, surveyType)
	if err != nil {
		return nil, err
	}
	return groups, nil
}

// CreateSurveyGroup cria um novo grupo de pesquisa
func CreateSurveyGroup(surveyId string, data models.CreateSurveyGroup) (models.SurveyGroup, error) {
	// ValidaÃ§Ã£o bÃ¡sica dos campos
	if surveyId == "" || data.SurveyType == "" {
		return models.SurveyGroup{}, errors.New("survey_id ou survey_type nÃ£o podem ser vazios")
	}

	group, err := repository.CreateSurveyGroup(surveyId, data)
	if err != nil {
		return models.SurveyGroup{}, err
	}
	return group, nil
}

// DeleteSurveyGroup remove um grupo de pesquisa pelo seu ID
func DeleteSurveyGroup(id string) error {
	if id == "" {
		return errors.New("id do grupo nÃ£o pode ser vazio")
	}

	err := repository.DeleteSurveyGroup(id)
	if err != nil {
		return err
	}
	return nil
}


============================================================


ðŸ“„ Arquivo : survey_region_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/survey_region_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"log"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
)

// Criar uma nova regiÃ£o vinculada a uma pesquisa
func CreateSurveyRegion(surveyId, surveyType string, regionData models.CreateSurveyRegion) (models.SurveyRegion, error) {
	surveyRegion, err := repository.CreateSurveyRegion(surveyId, surveyType, regionData)
	if err != nil {
		log.Println("[Service] Erro ao criar regiÃ£o de pesquisa:", err)
		return models.SurveyRegion{}, err
	}
	return surveyRegion, nil
}

// Buscar todas as regiÃµes vinculadas a uma pesquisa pelo ID
func GetAllSurveyRegionsBySurveyId(surveyId string) ([]models.SurveyRegion, error) {
	surveyRegions, err := repository.GetAllSurveyRegionsBySurveyId(surveyId)
	if err != nil {
		log.Println("[Service] Erro ao buscar regiÃµes por surveyId:", err)
		return nil, err
	}
	return surveyRegions, nil
}

// Buscar todas as regiÃµes de pesquisas de um tipo especÃ­fico
func GetAllSurveysBySurveyType(surveyType string) ([]models.SurveyRegion, error) {
	surveyRegions, err := repository.GetAllSurveysBySurveyType(surveyType)
	if err != nil {
		log.Println("[Service] Erro ao buscar regiÃµes por surveyType:", err)
		return nil, err
	}
	return surveyRegions, nil
}

// Buscar uma regiÃ£o especÃ­fica pelo ID
func GetSurveyRegionById(id string) (models.SurveyRegion, error) {
	surveyRegion, err := repository.GetSurveyRegionById(id)
	if err != nil {
		log.Println("[Service] Erro ao buscar regiÃ£o por ID:", err)
		return models.SurveyRegion{}, err
	}
	return surveyRegion, nil
}

// Atualizar uma regiÃ£o de pesquisa
func UpdateSurveyRegion(id string, data models.UpdateSurveyRegion) (models.SurveyRegion, error) {
	updatedRegion, err := repository.UpdateSurveyRegion(id, data)
	if err != nil {
		log.Println("[Service] Erro ao atualizar regiÃ£o de pesquisa:", err)
		return models.SurveyRegion{}, err
	}
	return updatedRegion, nil
}

// Deletar uma regiÃ£o de pesquisa
func DeleteSurveyRegion(id string) ([]models.SurveyRegion, error) {
	deleted, err := repository.DeleteSurveyRegion(id)
	if err != nil {
		log.Println("[Service] Erro ao deletar regiÃ£o de pesquisa:", err)
		return nil, err
	}
	return deleted, nil
}


============================================================


ðŸ“„ Arquivo : survey_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/survey_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"errors"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
)

// Criar uma nova pesquisa
func CreateSurvey(surveyType string, createSurveyData models.CreateSurvey) (models.Survey, error) {
	if createSurveyData.Title == "" || createSurveyData.ResearchId == "" {
		return models.Survey{}, errors.New("tÃ­tulo e ID da pesquisa sÃ£o obrigatÃ³rios")
	}

	return repository.CreateSurvey(surveyType, createSurveyData)
}

// Obter todas as pesquisas
func GetAllSurveys(surveyType string) ([]models.Survey, error) {
	if surveyType == "" {
		return nil, errors.New("o tipo de pesquisa Ã© obrigatÃ³rio")
	}

	return repository.GetAllSurveys(surveyType)
}

// Obter uma pesquisa por ID
func GetSurveyById(id, researchId, surveyType string) (models.Survey, error) {
	if id == "" {
		return models.Survey{}, errors.New("o ID da pesquisa Ã© obrigatÃ³rio")
	}

	return repository.GetSurveyById(id, researchId, surveyType)
}

// Atualizar uma pesquisa por ID
func UpdateSurveyById(id, surveyType string, updateData models.UpdateSurvey) (models.Survey, error) {
	if id == "" {
		return models.Survey{}, errors.New("o ID da pesquisa Ã© obrigatÃ³rio")
	}

	return repository.UpdateSurveyById(id, surveyType, updateData)
}

// Deletar uma pesquisa por ID
func DeleteSurveyById(id, surveyType string) (models.Survey, error) {
	if id == "" {
		return models.Survey{}, errors.New("o ID da pesquisa Ã© obrigatÃ³rio")
	}

	return repository.DeleteSurveyById(id, surveyType)
}

// ServiÃ§o para buscar pesquisas por research_id
func GetSurveysByResearchId(researchId, surveyType string) ([]models.Survey, error) {
	return repository.GetSurveysByResearchId(researchId, surveyType)
}


============================================================


ðŸ“„ Arquivo : survey_time_ranges_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/survey_time_ranges_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"log"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
)

func CreateSurveyTimeRange(surveyId, surveyType string, data models.CreateSurveyTimeRange) (models.SurveyTimeRange, error) {
	surveyTimeRange, err := repository.CreateSurveyTimeRange(surveyId, surveyType, data)
	if err != nil {
		log.Println("[Service] Erro ao criar intervalo de tempo de pesquisa:", err)
		return models.SurveyTimeRange{}, err
	}
	return surveyTimeRange, nil
}

func GetAllSurveyTimeRangeBySurveyId(surveyId string) ([]models.SurveyTimeRange, error) {
	surveyTimeRanges, err := repository.GetAllSurveyTimeRangeBySurveyId(surveyId)
	if err != nil {
		log.Println("[Service] Erro ao buscar intervalos de tempo por surveyId:", err)
		return nil, err
	}
	return surveyTimeRanges, nil
}

func GetAllSurveyTimeRangeBySurveyType(surveyType string) ([]models.SurveyTimeRange, error) {
	surveyTimeRanges, err := repository.GetAllSurveyRegionsBySurveyType(surveyType)
	if err != nil {
		log.Println("[Service] Erro ao buscar intervalos de tempo por surveyType:", err)
		return nil, err
	}
	return surveyTimeRanges, nil
}

func GetSurveyTimeRangeById(id string) (models.SurveyTimeRange, error) {
	surveyTimeRange, err := repository.GetSurveyTimeRangeById(id)
	if err != nil {
		log.Println("[Service] Erro ao buscar intervalo de tempo por ID:", err)
		return models.SurveyTimeRange{}, err
	}
	return surveyTimeRange, nil
}

func UpdateSurveyTimeRange(id string, data models.UpdateSurveyTimeRange) (models.SurveyTimeRange, error) {
	updatedSurveyTimeRange, err := repository.UpdateSurveyTimeRange(id, data)
	if err != nil {
		log.Println("[Service] Erro ao atualizar intervalo de tempo:", err)
		return models.SurveyTimeRange{}, err
	}
	return updatedSurveyTimeRange, nil
}

func DeleteSurveyTimeRange(id string) ([]models.SurveyTimeRange, error) {
	deleted, err := repository.DeleteSurveyTimeRange(id)
	if err != nil {
		log.Println("[Service] Erro ao deletar intervalo de tempo:", err)
		return nil, err
	}
	return deleted, nil
}


============================================================


ðŸ“„ Arquivo : token_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/token_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"errors"
	"fmt"
	"log"
	"math/rand"
	"placemaking-backend-go/config"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

const JWTAlgorithm = "HS256"
const JWTExpiresMinutes = 60 * 24 * 7
const RecoverPasswordExpiresMinutes = 5

func GenerateUserToken(user models.User, tokenType string) (*models.Token, error) {
	if tokenType == "Bearer" {
		existingToken, err := repository.GetTokenByUserID(user.ID, tokenType)
		if err == nil && existingToken != nil && existingToken.Active {
			// Converter string Expires_at para time.Time
			layout := "2006-01-02T15:04:05"
			expiresAt, err := time.Parse(layout, existingToken.Expires_at)
			if err != nil {
				log.Println("[GenerateUserToken] Erro ao converter Expires_at:", err)
				return nil, err
			}

			// Verifica se o token ainda Ã© vÃ¡lido
			if expiresAt.After(time.Now()) {
				return existingToken, nil
			}
		}
	}

	_ = repository.RevokeAllTokensByUserID(user.ID, tokenType)

	var newTokenData map[string]interface{}
	if tokenType == "Bearer" {
		newTokenData = GenerateJWTToken(user)
	} else {
		newTokenData = GenerateRecoverPasswordToken()
	}

	// Certificar que newTokenData["expires_at"] estÃ¡ no formato correto
	var expiresAt time.Time
	switch v := newTokenData["expires_at"].(type) {
	case string:
		layout := time.RFC3339
		var err error
		expiresAt, err = time.Parse(layout, v)
		if err != nil {
			log.Println("[GenerateUserToken] Erro ao converter expires_at:", err)
			return nil, err
		}
	case time.Time:
		expiresAt = v
	default:
		return nil, fmt.Errorf("[GenerateUserToken] Tipo inesperado para expires_at: %T", v)
	}

	token, err := repository.InsertToken(
		user.ID,
		newTokenData["token"].(string),
		tokenType,
		expiresAt,
	)

	if err != nil {
		log.Println("[GenerateUserToken] Erro ao inserir token:", err)
		return nil, err
	}

	return token, nil
}


func GenerateJWTToken(user models.User) map[string]interface{} {
	expire := time.Now().Add(time.Minute * time.Duration(JWTExpiresMinutes))

	claims := jwt.MapClaims{
		"sub":   user.ID,
		"email": user.Email,
		"role":  user.Role,
		"exp":   expire.Unix(),
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	signedToken, _ := token.SignedString([]byte(config.LoadSettings().JwtSecret))

	return map[string]interface{}{
		"token":      signedToken,
		"expires_at": expire,
	}
}

func GenerateRecoverPasswordToken() map[string]interface{} {
	expire := time.Now().Add(time.Minute * time.Duration(RecoverPasswordExpiresMinutes))

	token := generateRandomToken(8)

	return map[string]interface{}{
		"token":      token,
		"expires_at": expire,
	}
}

func VerifyToken(tokenString string) (jwt.MapClaims, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("mÃ©todo de assinatura invÃ¡lido")
		}
		return []byte(config.LoadSettings().JwtSecret), nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		return claims, nil
	}

	return nil, errors.New("token invÃ¡lido")
}

func RevokeToken(token string) error {
	return repository.RevokeToken(token)
}

func generateRandomToken(length int) string {
	rand.Seed(time.Now().UnixNano()) // Garante nÃºmeros aleatÃ³rios diferentes a cada execuÃ§Ã£o
	const digits = "0123456789"
	token := make([]byte, length)
	for i := range token {
		token[i] = digits[rand.Intn(len(digits))]
	}
	return string(token)
}

============================================================


ðŸ“„ Arquivo : user_service.go
ðŸ“‚ Pasta   : services
ðŸ§­ Caminho : services/user_service.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package services

import (
	"log"
	"math/rand"
	"placemaking-backend-go/models"
	repository "placemaking-backend-go/repositories"
	"time"

	"golang.org/x/crypto/bcrypt"
)

func FetchUserById(id string) (models.User, error) {
	user, err := repository.GetUserById(id)
	if err != nil {
		return models.User{}, err
	}
	return user, nil
}

func FetchAllUsers() ([]models.SanitizedUser, error) {
	users, err := repository.GetAllUsers()
	if err != nil {
		return []models.SanitizedUser{}, err
	}

	return users, nil
}

func FetchDeleteUser(id string) error {
	err := repository.DeleteUserById(id)
	if err != nil {
		return err
	}
	return nil
}

func FetchUpdateUser(id string, user models.User) (models.User, error) {

	updatedData := map[string]interface{}{
		"name":       user.Name,
		"email":      user.Email,
		"role":       user.Role,
		"updated_at": time.Now().Format(time.RFC3339),
		"status":     user.Status,
	}

	user, err := repository.UpdateUserById(id, updatedData)

	if err != nil {
		return models.User{}, err
	}

	return user, nil
}

func GenerateUserPassword() string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	rand.Seed(time.Now().UnixNano())
	password := make([]byte, 8)
	for i := range password {
		password[i] = charset[rand.Intn(len(charset))]
	}
	return string(password)
}

func GenerateHashedPassword(password string) (string, error) {
	salt, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(salt), nil
}

func CheckPassword(plainPassword string, hashedPassword string) bool {
	// Verifica se os valores nÃ£o estÃ£o vazios
	if plainPassword == "" || hashedPassword == "" {
		return false
	}

	// Compara a senha em texto com o hash armazenado
	err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(plainPassword))
	if err != nil {
		log.Println("Erro ao verificar senha:", err)
		return false
	}

	return true
}


============================================================


ðŸ“„ Arquivo : templates.go
ðŸ“‚ Pasta   : templates
ðŸ§­ Caminho : templates/templates.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package templates

import "embed"

//go:embed assets/templates/*.html
var FS embed.FS


============================================================


ðŸ“„ Arquivo : utils.go
ðŸ“‚ Pasta   : utils
ðŸ§­ Caminho : utils/utils.go
--------------------------------------
ðŸ“œ ConteÃºdo:

package utils

import (
	"time"
)

func ParseTimestamp(t string) (string, error) {
	parsedTime, err := time.Parse("2006-01-02T15:04:05.999999", t)
	if err != nil {
		return "", err
	}
	return parsedTime.Format(time.RFC3339), nil
}


============================================================


ðŸ“„ Arquivo : vercel.json
ðŸ“‚ Pasta   : .
ðŸ§­ Caminho : vercel.json
--------------------------------------
ðŸ“œ ConteÃºdo:

{
  "version": 2,
  "builds": [
    {
      "src": "main.go",
      "use": "@vercel/go"
    }
  ],
  "routes": [
    {
      "src": "/.*",
      "dest": "main.go"
    }
  ]
}


============================================================


